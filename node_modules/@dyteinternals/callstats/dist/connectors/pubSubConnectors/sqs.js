import { ClientEnvType, } from '../../types';
import PubSubConnector from './pubSub';
// import aws4 from 'aws4';
import { sign } from '../../utils/aws4';
export default class SQSConnector extends PubSubConnector {
    config;
    logger;
    sqsApiEndpoint;
    ingestionLayerDetails;
    constructor(env, ingestionLayerDetails, logger) {
        super();
        this.logger = logger;
        this.config = {
            region: 'ap-south-1',
            credentials: {
                accessKeyId: atob('QUtJQTVZQUh' + 'SS1pSQklZTjdXVTc='),
                secretAccessKey: atob('YVpIM2Y5SHlHZnp6ZDZ4' + 'OHg5SkhaZzlUcGVPS2Z0cE92MUk3bE1HKw=='),
            },
        };
        if (env === ClientEnvType.PRODUCTION) {
            this.config.queue = '/944908621410/Callstats-Queue';
            this.sqsApiEndpoint = 'https://collector.prod.da.dyte.io/api/v1/message';
        }
        else {
            this.config.queue = '/944908621410/Callstats-Queue';
            this.sqsApiEndpoint = 'https://collector.non-prod.da.dyte.io/api/v1/message';
        }
        this.ingestionLayerDetails = ingestionLayerDetails ?? 'SQS';
    }
    sendChunk(data) {
        super.sendChunk(data);
    }
    async sendDirectly(packet) {
        const params = new URLSearchParams({
            Action: 'SendMessage',
            MessageBody: JSON.stringify(packet),
            // Version: '2012-11-05'
        });
        const opts = sign({
            service: 'sqs',
            region: this.config.region,
            path: `${this.config.queue}/?${params.toString()}`,
        }, this.config.credentials);
        const command = `https://${opts.hostname}${opts.path}`;
        await fetch(command, opts);
    }
    async sendToNewIngestionLayer(packet) {
        await fetch(this.sqsApiEndpoint, {
            method: 'POST',
            body: JSON.stringify(packet),
        });
    }
    async sendChunkToServer(data) {
        const packet = {
            payload: data,
            peerId: this.authInfo?.peerId,
        };
        const requests = [];
        try {
            // this.logger.debug('callStats::sqs::sendChunkToServer', { data: JSON.stringify(data) });
            if (this.ingestionLayerDetails === 'INGESTION' || this.ingestionLayerDetails === 'ALL') {
                requests.push(this.sendToNewIngestionLayer(packet));
            }
            if (this.ingestionLayerDetails === 'SQS' || this.ingestionLayerDetails === 'ALL') {
                requests.push(this.sendDirectly(packet));
            }
            const results = await Promise.allSettled(requests);
            results.forEach((result) => {
                if (result.status === 'rejected') {
                    this.logger.error('callStats::sqs::sendChunkToServer', { error: { reason: result.reason } });
                }
            });
            return true;
            // process data.
        }
        catch (error) {
            // error handling.
            this.logger.error('callStats::sqs::sendChunkToServer::catch', { error: { reason: error.reason, message: error.message } });
            return false;
        }
    }
}
