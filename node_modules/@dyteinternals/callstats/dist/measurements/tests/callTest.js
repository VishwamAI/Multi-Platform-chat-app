import EventEmitter from 'events';
export class CallTest {
    pc1;
    pc2;
    constrainVideoBitrateKbps;
    constrainOfferToRemoveVideoFec = false;
    iceCandidateFilter;
    static parseCandidate(text) {
        const candidateStr = 'candidate:';
        const pos = text.indexOf(candidateStr) + candidateStr.length;
        const fields = text.substr(pos).split(' ');
        return {
            type: fields[7],
            protocol: fields[2],
            address: fields[4],
        };
    }
    static isNotHostCandidate(candidate) {
        return candidate.type !== 'host';
    }
    static isHost(candidate) {
        return candidate.type === 'host';
    }
    static isRelay(candidate) {
        return candidate.type === 'relay';
    }
    static isReflexive(candidate) {
        return candidate.type === 'srflx';
    }
    static noFilter(parsed) {
        return true;
    }
    constructor(config) {
        const pc1 = new RTCPeerConnection(config);
        const pc2 = new RTCPeerConnection(config);
        this.pc1 = pc1;
        this.pc2 = pc2;
        this.iceCandidateFilter = CallTest.noFilter;
        this.pc1.addEventListener('icecandidate', this.onIceCandidate.bind(this, this.pc2));
        this.pc2.addEventListener('icecandidate', this.onIceCandidate.bind(this, this.pc1));
    }
    onIceCandidate(otherPeer, event) {
        if (event.candidate) {
            const parsed = CallTest.parseCandidate(event.candidate.candidate);
            // console.log("Candidate", parsed);
            if (this.iceCandidateFilter(parsed)) {
                otherPeer.addIceCandidate(event.candidate);
            }
        }
    }
    setIceCandidateFilter(filter) {
        this.iceCandidateFilter = filter;
    }
    // Constraint max video bitrate by modifying the SDP when creating an answer.
    constrainVideoBitrate(maxVideoBitrateKbps) {
        this.constrainVideoBitrateKbps = maxVideoBitrateKbps;
    }
    // Remove video FEC if available on the offer.
    disableVideoFec() {
        this.constrainOfferToRemoveVideoFec = true;
    }
    gotOffer(offer) {
        if (this.constrainOfferToRemoveVideoFec) {
            offer.sdp = offer.sdp.replace(/(m=video 1 [^\r]+)(116 117)(\r\n)/g, '$1\r\n');
            offer.sdp = offer.sdp.replace(/a=rtpmap:116 red\/90000\r\n/g, '');
            offer.sdp = offer.sdp.replace(/a=rtpmap:117 ulpfec\/90000\r\n/g, '');
            offer.sdp = offer.sdp.replace(/a=rtpmap:98 rtx\/90000\r\n/g, '');
            offer.sdp = offer.sdp.replace(/a=fmtp:98 apt=116\r\n/g, '');
        }
        this.pc1.setLocalDescription(offer);
        this.pc2.setRemoteDescription(offer);
        this.pc2.createAnswer().then(this.gotAnswer.bind(this), this.reportFatal.bind(this));
    }
    gotAnswer(answer) {
        if (this.constrainVideoBitrateKbps) {
            answer.sdp = answer.sdp.replace(/a=mid:video\r\n/g, `a=mid:video\r\nb=AS:${this.constrainVideoBitrateKbps}\r\n`);
        }
        this.pc2.setLocalDescription(answer);
        this.pc1.setRemoteDescription(answer);
        // console.log("Connection Established!");
    }
    establishConnection() {
        this.pc1.createOffer().then(this.gotOffer.bind(this), this.reportFatal.bind(this));
    }
    // eslint-disable-next-line class-methods-use-this
    reportFatal(reason) {
        // eslint-disable-next-line no-console
        console.error('Error:', reason);
    }
    async getRoundTripTime() {
        const [sendStats, recieveStats] = await Promise.all([this.pc1.getStats(), this.pc2.getStats()]);
        let sendPairStats;
        let recievePairStats;
        sendStats.forEach((e) => {
            if (e.type === 'candidate-pair' && e.nominated === true && e.bytesSent > 0) {
                sendPairStats = e;
            }
        });
        recieveStats.forEach((e) => {
            if (e.type === 'candidate-pair' && e.nominated === true && e.bytesReceived > 0) {
                recievePairStats = e;
            }
        });
        // console.log("Send, receieve pair stats", sendPairStats, recievePairStats);
        if (sendPairStats && recievePairStats) {
            try {
                // sendPairStats['lastPacketSentTimestamp'] - sendPairStats['lastPacketSentTimestamp']
                if (sendPairStats.currentRoundTripTime && recievePairStats.currentRoundTripTime) {
                    return {
                        rtt: sendPairStats.currentRoundTripTime,
                        backendRTT: recievePairStats.currentRoundTripTime,
                    };
                }
                const rtt = (recievePairStats.lastPacketReceivedTimestamp
                    - sendPairStats.lastPacketSentTimestamp)
                    / 1000.0;
                // const backendRTT = (sendPairStats['lastPacketReceivedTimestamp']
                //  	- recievePairStats['lastPacketSentTimestamp']
                //  ) / 1000.0;
                return {
                    rtt,
                    backendRTT: rtt,
                };
            }
            catch {
                return undefined;
            }
        }
        return undefined;
    }
    close() {
        this.pc1.close();
        this.pc2.close();
    }
}
export class SimpleCallTest extends EventEmitter {
    call;
    timeOut;
    constructor(config) {
        super();
        this.call = new CallTest(config);
    }
    start(timeout = 10000) {
        // console.log("connecting...");
        this.call.establishConnection();
        this.timeOut = setTimeout(this.testFailed.bind(this), timeout); // Timeout of 5 seconds
    }
    testComplete(data) {
        clearTimeout(this.timeOut);
        this.call.close();
        this.emit('done', data);
    }
    testFailed(error) {
        // eslint-disable-next-line no-console
        console.warn('Test failed, ', error);
        this.call.close();
        this.emit('failed', error);
    }
}
