/* eslint-disable no-plusplus */
import { CallTest, SimpleCallTest } from './callTest';
const BYTES_TO_BITS = 8;
const BITS_TO_KILOBITS = 1 / 1000;
export default class DataThroughputTest extends SimpleCallTest {
    senderChannel;
    recieveChannel;
    startTime;
    lastBitrateMeasureTime;
    sentPayloadBytes = 0;
    recievedPayloadBytes = 0;
    lastReceivedPayloadBytes = 0;
    stopSending = false;
    testProgress = 0;
    samplePacket = '';
    finalBitrateSum = 0;
    bitRateSampels = 0;
    maxNumberOfPacketsToSend = 0;
    bytesToKeepBuffered = 0;
    testDurationSeconds = 5.0;
    constructor(config) {
        super(config);
        this.call.setIceCandidateFilter(CallTest.isNotHostCandidate);
        this.senderChannel = this.call.pc1.createDataChannel(null);
        // 256 KiB packet
        // See https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Using_data_channels#understanding_message_size_limits
        // See https://stackoverflow.com/questions/56327783/webrtc-datachannel-for-high-bandwidth-application
        // On limitations of datachannel max message size and throttling
        for (let i = 0; i < 1024 * 256; i += 1) {
            this.samplePacket += 'h';
        }
        this.maxNumberOfPacketsToSend = 1;
        this.bytesToKeepBuffered = 1024 * this.maxNumberOfPacketsToSend;
        this.testDurationSeconds = 4.0;
        this.senderChannel.addEventListener('open', this.sendingStep.bind(this));
        this.call.pc2.addEventListener('datachannel', this.onRecieverChannel.bind(this));
    }
    sendingStep() {
        const now = new Date();
        if (!this.startTime) {
            this.startTime = now;
            this.lastBitrateMeasureTime = now;
        }
        for (let i = 0; i !== this.maxNumberOfPacketsToSend; i += 1) {
            if (this.senderChannel.bufferedAmount >= this.bytesToKeepBuffered) {
                break;
            }
            this.sentPayloadBytes += this.samplePacket.length;
            try {
                this.senderChannel.send(this.samplePacket);
                // eslint-disable-next-line no-empty
            }
            catch {
            }
        }
        const duration = now.getTime() - this.startTime.getTime();
        if (duration >= 1000 * this.testDurationSeconds) {
            this.stopSending = true;
            this.testProgress = 100;
            // console.log("Test completed!");
        }
        else {
            this.testProgress = duration / (10 * this.testDurationSeconds);
            setTimeout(this.sendingStep.bind(this), 1);
        }
    }
    onMessageRecieved(event) {
        this.recievedPayloadBytes += event.data.length;
        const now = new Date();
        const duration = now.getTime() - this.lastBitrateMeasureTime.getTime();
        if (duration >= 1000) {
            // Convert bytes to bits/s
            const deltaBytes = this.recievedPayloadBytes - this.lastReceivedPayloadBytes;
            const bitrate = (deltaBytes * BYTES_TO_BITS) / (duration / 1000);
            this.finalBitrateSum += bitrate;
            this.bitRateSampels += 1;
            this.lastReceivedPayloadBytes = this.recievedPayloadBytes;
            this.lastBitrateMeasureTime = now;
        }
        if (this.stopSending && this.sentPayloadBytes === this.recievedPayloadBytes) {
            // Calculate average bitrate in kilobits/s
            const averageBitrate = this.finalBitrateSum / this.bitRateSampels;
            this.testComplete({
                throughput: Math.round(averageBitrate * BITS_TO_KILOBITS),
            });
        }
    }
    testComplete(data) {
        this.call.getRoundTripTime().then(({ rtt, backendRTT }) => super.testComplete({
            RTT: rtt,
            backendRTT,
            throughput: data.throughput,
        }));
    }
    onRecieverChannel(event) {
        this.recieveChannel = event.channel;
        this.recieveChannel.addEventListener('message', this.onMessageRecieved.bind(this));
    }
}
