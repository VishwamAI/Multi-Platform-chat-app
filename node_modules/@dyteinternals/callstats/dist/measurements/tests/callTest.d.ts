/// <reference types="node" />
import EventEmitter from 'events';
export interface ParsedIceCandidate {
    type: string;
    protocol: string;
    address: string;
}
export declare class CallTest {
    pc1: RTCPeerConnection;
    pc2: RTCPeerConnection;
    constrainVideoBitrateKbps: number;
    constrainOfferToRemoveVideoFec: boolean;
    iceCandidateFilter: (parsed: ParsedIceCandidate) => boolean;
    static parseCandidate(text: string): ParsedIceCandidate;
    static isNotHostCandidate(candidate: ParsedIceCandidate): boolean;
    static isHost(candidate: ParsedIceCandidate): boolean;
    static isRelay(candidate: ParsedIceCandidate): boolean;
    static isReflexive(candidate: ParsedIceCandidate): boolean;
    static noFilter(parsed: ParsedIceCandidate): boolean;
    constructor(config: RTCConfiguration);
    onIceCandidate(otherPeer: RTCPeerConnection, event: RTCPeerConnectionIceEvent): void;
    setIceCandidateFilter(filter: (parsed: ParsedIceCandidate) => boolean): void;
    constrainVideoBitrate(maxVideoBitrateKbps: number): void;
    disableVideoFec(): void;
    gotOffer(offer: RTCSessionDescriptionInit): void;
    gotAnswer(answer: RTCSessionDescriptionInit): void;
    establishConnection(): void;
    reportFatal(reason: any): void;
    getRoundTripTime(): Promise<{
        rtt: number;
        backendRTT: number;
    }>;
    close(): void;
}
export declare abstract class SimpleCallTest extends EventEmitter {
    call: CallTest;
    timeOut: NodeJS.Timeout;
    constructor(config: RTCConfiguration);
    start(timeout?: number): void;
    protected testComplete(data: any): any;
    protected testFailed(error: string): void;
}
