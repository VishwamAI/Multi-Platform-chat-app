import DataThroughputTest from './tests/bandwidthTest';
import { HostConnectivityTest, RelayConnectivityTest, ReflexiveConnectivityTest } from './tests/connectivityTest';
import ipDetails from '../utils/ipDetails';
export const FALLBACK_ICE_SERVERS = [
    {
        urls: 'turn:turn.dyte.in:443?transport=tcp',
        username: 'dyte',
        credential: 'dytein',
        credentialType: 'password',
    },
    {
        urls: 'turn:turn.dyte.in:3478?transport=udp',
        username: 'dyte',
        credential: 'dytein',
        credentialType: 'password',
    },
];
export function parseIpLocation(loc) {
    const [latitude, longitude] = loc.split(',');
    return {
        coords: {
            latitude: Number(latitude),
            longitude: Number(longitude),
        },
    };
}
export class ParsedRTCStats {
    transport;
    candidatePair;
    outboundVideoRtp = new Map();
    inboundVideoRtp = new Map();
    outboundAudioRtp = new Map();
    inboundAudioRtp = new Map();
    remoteInboundRtp = new Map();
    producerStreamMap = new Map();
    consumerStreamMap = new Map();
    staleProducerStreamMap = false;
    staleConsumerStreamMap = false;
}
export class Measurements {
    outboundProducerMap = new Map();
    inboundConsumerMap = new Map();
    consumerPeerIdMap = new Map();
    overallProducingTransportsStatsMap = {};
    overallConsumingTransportsStatsMap = {};
    overallConsumersStatsMap = {};
    overallProducersStatsMap = {};
    consumerIdsWithFreezedVideo = new Set();
    consumerIdsWithFreezedAudio = new Set();
    producerIdsWithFreezedVideo = new Set();
    producerIdsWithFreezedAudio = new Set();
    freezedProducingTransportIds = new Set();
    freezedConsumingTransportIds = new Set();
    ipDetails;
    callStatsInstance;
    async registerProducer(producer) {
        await this.generateProducerStreamMap(producer);
        producer.observer.on('close', this.deregisterProducer.bind(this, producer));
    }
    processInboundConsumerVideoStats(consumerId, overallStatsForConsumer, streamStatsData) {
        const consumerMediaStates = this
            ?.callStatsInstance
            ?.consumerSharedMediaStatesMap
            ?.get(consumerId) || {};
        if (overallStatsForConsumer.totalVideoPacketsReceived === streamStatsData.packetsReceived) {
            this.consumerIdsWithFreezedVideo.add(consumerId);
            if (this.callStatsInstance && consumerMediaStates.video) {
                this.callStatsInstance.logger.debug('callstats::measurements::consumerVideoFreezed', { consumerId });
                this.callStatsInstance.eventHandler.emit('consumer_video_status', 'pause', consumerId);
            }
        }
        else {
            overallStatsForConsumer.totalVideoPacketsReceived = streamStatsData.packetsReceived;
            if (this.consumerIdsWithFreezedVideo.has(consumerId)) {
                this.consumerIdsWithFreezedVideo.delete(consumerId);
                if (this.callStatsInstance && consumerMediaStates.video) {
                    this.callStatsInstance.logger.debug('callstats::measurements::consumerVideoDefreezed', { consumerId });
                    this.callStatsInstance.eventHandler.emit('consumer_video_status', 'resume', consumerId);
                }
            }
        }
    }
    processInboundConsumerAudioStats(consumerId, overallStatsForConsumer, streamStatsData) {
        const consumerMediaStates = this
            ?.callStatsInstance
            ?.consumerSharedMediaStatesMap
            ?.get(consumerId) || {};
        if (overallStatsForConsumer.totalAudioPacketsReceived === streamStatsData.packetsReceived) {
            this.consumerIdsWithFreezedAudio.add(consumerId);
            if (this.callStatsInstance && consumerMediaStates.audio) {
                this.callStatsInstance.logger.debug('callStats::measurements::consumerAudioFreezed', { consumerId });
                this.callStatsInstance.eventHandler.emit('consumer_audio_status', 'pause', consumerId);
            }
        }
        else {
            overallStatsForConsumer.totalAudioPacketsReceived = streamStatsData.packetsReceived;
            if (this.consumerIdsWithFreezedAudio.has(consumerId)) {
                this.consumerIdsWithFreezedAudio.delete(consumerId);
                if (this.callStatsInstance && consumerMediaStates.audio) {
                    this.callStatsInstance.logger.debug('callStats::measurements::consumerAudioDefreezed', { consumerId });
                    this.callStatsInstance.eventHandler.emit('consumer_audio_status', 'resume', consumerId);
                }
            }
        }
    }
    processOutboundProducerVideoStats(producerId, overallStatsForProducer, streamStatsData) {
        const currentUserMediaStates = this
            ?.callStatsInstance
            ?.currentUserMediaStates
            || {};
        if (overallStatsForProducer.totalVideoPacketsSent === streamStatsData.packetsSent) {
            this.producerIdsWithFreezedVideo.add(producerId);
            if (this.callStatsInstance && currentUserMediaStates.video) {
                this.callStatsInstance.logger.debug('callStats::measurements::producerVideoFreezed', { producerId });
                this.callStatsInstance.eventHandler.emit('producer_video_status', 'pause', producerId);
            }
        }
        else {
            overallStatsForProducer.totalVideoPacketsSent = streamStatsData.packetsSent;
            if (this.producerIdsWithFreezedVideo.has(producerId)) {
                this.producerIdsWithFreezedVideo.delete(producerId);
                if (this.callStatsInstance && currentUserMediaStates.video) {
                    this.callStatsInstance.logger.debug('callStats::measurements::producerVideoDefreezed', { producerId });
                    this.callStatsInstance.eventHandler.emit('producer_video_status', 'resume', producerId);
                }
            }
        }
    }
    processOutboundProducerAudioStats(producerId, overallStatsForProducer, streamStatsData) {
        const currentUserMediaStates = this
            ?.callStatsInstance
            ?.currentUserMediaStates
            || {};
        if (overallStatsForProducer.totalAudioPacketsSent === streamStatsData.packetsSent) {
            this.producerIdsWithFreezedAudio.add(producerId);
            if (this.callStatsInstance && currentUserMediaStates.audio) {
                this.callStatsInstance.logger.debug('callStats::measurements::producerAudioFreezed', { producerId });
                this.callStatsInstance.eventHandler.emit('producer_audio_status', 'pause', producerId);
            }
        }
        else {
            overallStatsForProducer.totalAudioPacketsSent = streamStatsData.packetsSent;
            if (this.producerIdsWithFreezedAudio.has(producerId)) {
                this.producerIdsWithFreezedAudio.delete(producerId);
                if (this.callStatsInstance && currentUserMediaStates.audio) {
                    this.callStatsInstance.logger.debug('callStats::measurements::producerAudioDefreezed', { producerId });
                    this.callStatsInstance.eventHandler.emit('producer_audio_status', 'resume', producerId);
                }
            }
        }
    }
    processProducingTransportStats(transportId, overallStatsForTransport, transportStatsData) {
        const currentUserMediaStates = this
            ?.callStatsInstance
            ?.currentUserMediaStates
            || {};
        const { audio: audioIsOn, video: videoIsOn, screen: screenIsOn } = currentUserMediaStates;
        const isAnyProducerActivityOn = audioIsOn || videoIsOn || screenIsOn;
        if (overallStatsForTransport.totalPacketsSent === transportStatsData.packetsSent) {
            this.freezedProducingTransportIds.add(transportId);
            if (this.callStatsInstance && isAnyProducerActivityOn) {
                this.callStatsInstance.logger.debug('callStats::measurements::producingTransportFreezed', { transportId });
                this.callStatsInstance.eventHandler.emit('producing_transport_status', 'pause', transportId);
            }
        }
        else {
            overallStatsForTransport.totalPacketsSent = transportStatsData.packetsSent;
            if (this.freezedProducingTransportIds.has(transportId)) {
                this.freezedProducingTransportIds.delete(transportId);
                if (this.callStatsInstance && isAnyProducerActivityOn) {
                    this.callStatsInstance.logger.debug('callStats::measurements::producingTransportDefreezed', { transportId });
                    this.callStatsInstance.eventHandler.emit('producing_transport_status', 'resume', transportId);
                }
            }
        }
    }
    processConsumingTransportStats(transportId, overallStatsForTransport, streamStatsData) {
        const combindConsumerStates = Array.from(this
            ?.callStatsInstance
            ?.consumerSharedMediaStatesMap
            ?.values() || []);
        const isAnyConsumerActivityOn = !!combindConsumerStates
            .reduce((acc, val) => acc || val.audio || val.video || val.screen, false);
        if (overallStatsForTransport.totalPacketsReceived === streamStatsData.packetsSent) {
            this.freezedConsumingTransportIds.add(transportId);
            if (this.callStatsInstance && isAnyConsumerActivityOn) {
                this.callStatsInstance.logger.debug('callStats::measurements::consumingTransportFreezed', { transportId });
                this.callStatsInstance.eventHandler.emit('consuming_transport_status', 'pause', transportId);
            }
        }
        else {
            overallStatsForTransport.totalPacketsReceived = streamStatsData.packetsSent;
            if (this.freezedConsumingTransportIds.has(transportId)) {
                this.freezedConsumingTransportIds.delete(transportId);
                if (this.callStatsInstance && isAnyConsumerActivityOn) {
                    this.callStatsInstance.logger.debug('callStats::measurements::consumingTransportDefreezed', { transportId });
                    this.callStatsInstance.eventHandler.emit('consuming_transport_status', 'resume', transportId);
                }
            }
        }
    }
    async registerConsumer(consumer) {
        await this.generateConsumerStreamMap(consumer);
        this.consumerPeerIdMap.set(consumer.id, {
            producerId: consumer.producerId,
            peerId: consumer.appData.peerId,
        });
        consumer.observer.on('close', this.deregisterConsumer.bind(this, consumer));
    }
    async generateProducerStreamMap(producer, parse = false) {
        const stat = await producer.getStats();
        const result = parse ? this.getProducerStatsFromReport(this.parseRTCReport(stat, ['outbound-rtp', 'remote-inbound-rtp'], false, producer.id))[0] : undefined;
        for (const entry of stat.values()) {
            switch (entry.type) {
                case 'outbound-rtp': {
                    this.outboundProducerMap.set(entry.id, producer.id);
                    break;
                }
                default:
                    break;
            }
        }
        // console.log("OutboundMap: ", this.outboundProducerMap, stat, producer);
        return result;
    }
    async generateConsumerStreamMap(consumer, parse = false) {
        const stat = await consumer.getStats();
        const result = parse ? this.getConsumerStatsFromReport(this.parseRTCReport(stat, ['inbound-rtp'], false, consumer.id))[0] : undefined;
        for (const entry of stat.values()) {
            switch (entry.type) {
                case 'inbound-rtp': {
                    this.inboundConsumerMap.set(entry.id, consumer.id);
                    break;
                }
                default:
                    break;
            }
        }
        // console.log("Inbound: ", this.inboundConsumerMap, stat, consumer);
        return result;
    }
    deregisterProducer(producer) {
        this.outboundProducerMap.forEach((value, key) => {
            if (value === producer.id) {
                this.outboundProducerMap.delete(key);
            }
        });
    }
    deregisterConsumer(consumer) {
        this.inboundConsumerMap.forEach((value, key) => {
            if (value === consumer.id) {
                this.inboundConsumerMap.delete(key);
            }
        });
        this.consumerPeerIdMap.delete(consumer.id);
    }
    parseRTCReport(report, filters = [], onceOnly = false, ownerId = undefined, transportInfo = undefined) {
        const stat = report;
        const result = new ParsedRTCStats();
        const filtersSet = filters.length ? new Set(filters) : undefined;
        for (const entry of stat.values()) {
            if (filtersSet) {
                if (filtersSet.size === 0) {
                    break;
                }
                else if (!filtersSet.has(entry.type)) {
                    // Entry not in filtersSet so skip it
                    // eslint-disable-next-line no-continue
                    continue;
                }
                else if (onceOnly) {
                    filtersSet.delete(entry.type); // Delete cuz its gonna be parsed
                }
            }
            switch (entry.type) {
                case 'candidate-pair': {
                    /**
                     * Note(ravindra-dyte):
                     * nominated is supported in Safari & Chrome whereas selected is supported in Firefox.
                     * However only chrome uses this file
                     */
                    if (entry.nominated === true || entry.selected === true) {
                        const candidateStats = entry;
                        const data = {
                            bytesReceived: candidateStats.bytesReceived,
                            bytesSent: candidateStats.bytesSent,
                            currentRoundTripTime: candidateStats.currentRoundTripTime,
                            totalRoundTripTime: candidateStats.totalRoundTripTime,
                            availableOutgoingBitrate: candidateStats.availableOutgoingBitrate,
                        };
                        result.candidatePair = data;
                        break;
                    }
                    break;
                }
                case 'transport': {
                    const transportStats = entry;
                    if (transportInfo) {
                        if (transportInfo.producing) {
                            if (!this.overallProducingTransportsStatsMap[transportInfo.id]) {
                                this.overallProducingTransportsStatsMap[transportInfo.id] = {
                                    totalPacketsSent: 0,
                                };
                            }
                        }
                        if (transportInfo.consuming) {
                            if (!this.overallConsumingTransportsStatsMap[transportInfo.id]) {
                                this.overallConsumingTransportsStatsMap[transportInfo.id] = {
                                    totalPacketsReceived: 0,
                                };
                            }
                        }
                    }
                    const data = {
                        bytesReceived: transportStats.bytesReceived,
                        bytesSent: transportStats.bytesSent,
                        packetsSent: transportStats.packetsSent,
                        packetsReceived: transportStats.packetsReceived,
                        dtlsCipher: transportStats.dtlsCipher,
                        dtlsState: transportStats['dtlsState'],
                        iceRole: transportStats['iceRole'],
                    };
                    result.transport = data;
                    if (transportInfo) {
                        if (transportInfo.producing) {
                            const overallStatsForTransport = this.overallProducingTransportsStatsMap[transportInfo.id];
                            this.processProducingTransportStats(transportInfo.id, overallStatsForTransport, data);
                        }
                        if (transportInfo.consuming) {
                            const overallStatsForTransport = this.overallConsumingTransportsStatsMap[transportInfo.id];
                            this.processConsumingTransportStats(transportInfo.id, overallStatsForTransport, data);
                        }
                    }
                    // There is only 1 transport entry, and so return here itself;
                    // return result;
                    break;
                }
                case 'remote-inbound-rtp': {
                    // Mediasoup apparently dosent implement RTCRemoteInboundRtpStreamStats
                    const rtpStreamStats = entry;
                    const data = {
                        jitter: rtpStreamStats.jitter,
                        fractionLost: rtpStreamStats.fractionLost,
                        roundTripTime: rtpStreamStats.roundTripTime,
                        roundTripTimeMeasurements: rtpStreamStats.roundTripTimeMeasurements,
                        totalRoundTripTime: rtpStreamStats.totalRoundTripTime,
                        packetsLost: rtpStreamStats.packetsLost,
                    };
                    result.remoteInboundRtp.set(rtpStreamStats.localId, data);
                    break;
                }
                case 'outbound-rtp': {
                    const rtpStreamStats = entry; // RTCOutboundRTPStreamStats
                    const producerId = ownerId || this.outboundProducerMap.get(entry.id);
                    if (!this.overallProducersStatsMap[producerId]) {
                        this.overallProducersStatsMap[producerId] = {
                            totalVideoPacketsSent: 0,
                            totalAudioPacketsSent: 0,
                        };
                    }
                    const overallStatsForProducer = this.overallProducersStatsMap[producerId];
                    if (['video', 'audio'].includes(rtpStreamStats.mediaType)) {
                        if (!this.outboundProducerMap.has(entry.id)) {
                            // console.log('Outbound-RTP Stream found but no matching producer exists!', entry.id);
                            result.staleProducerStreamMap = true;
                            if (filtersSet) {
                                filtersSet.delete('outbound-rtp');
                            }
                            break;
                        }
                        if (!result.producerStreamMap.has(producerId)) {
                            result.producerStreamMap.set(producerId, {
                                outboundVideoRtpId: [],
                                outboundAudioRtpId: [],
                            });
                        }
                        const outboundData = {
                            bytesSent: rtpStreamStats.bytesSent,
                            packetsSent: rtpStreamStats.packetsSent,
                            nackCount: rtpStreamStats.nackCount,
                        };
                        if (rtpStreamStats.mediaType === 'video') {
                            if (rtpStreamStats.decoderImplementation === 'unknown') {
                                break;
                            }
                            const videoRtpStreamStats = rtpStreamStats;
                            const data = {
                                frameHeight: videoRtpStreamStats.frameHeight,
                                frameWidth: videoRtpStreamStats.frameWidth,
                                framesEncoded: videoRtpStreamStats.framesEncoded,
                                framesDropped: videoRtpStreamStats.framesDropped,
                                framesPerSecond: videoRtpStreamStats.framesPerSecond,
                                framesSent: videoRtpStreamStats.framesSent,
                                keyFramesEncoded: videoRtpStreamStats.keyFramesEncoded,
                                firCount: videoRtpStreamStats.firCount,
                                encoderImplementation: videoRtpStreamStats.encoderImplementation,
                                hugeFramesSent: videoRtpStreamStats.hugeFramesSent,
                                pliCount: videoRtpStreamStats.pliCount,
                                qpSum: videoRtpStreamStats.qpSum,
                                qualityLimitationDurations: videoRtpStreamStats.qualityLimitationDurations,
                                qualityLimitationReason: videoRtpStreamStats.qualityLimitationReason,
                                qualityLimitationResolutionChanges: videoRtpStreamStats.qualityLimitationResolutionChanges,
                                // temp sending target bitrate in total encode time
                                // to avoid the delay with making the backend changes
                                totalEncodeTime: videoRtpStreamStats.targetBitrate,
                                totalPacketSendDelay: videoRtpStreamStats.totalPacketSendDelay,
                                retransmittedBytesSent: videoRtpStreamStats.retransmittedBytesSent,
                                retransmittedPacketsSent: videoRtpStreamStats.retransmittedPacketsSent,
                                ...outboundData,
                            };
                            result.outboundVideoRtp.set(entry.id, data);
                            result.producerStreamMap.get(producerId).outboundVideoRtpId.push(entry.id);
                            this.processOutboundProducerVideoStats(producerId, overallStatsForProducer, data);
                        }
                        else if (rtpStreamStats.mediaType === 'audio') {
                            const audioStreamStats = rtpStreamStats;
                            const data = {
                                retransmittedBytesSent: audioStreamStats.retransmittedBytesSent,
                                retransmittedPacketsSent: audioStreamStats.retransmittedPacketsSent,
                                ...outboundData,
                            };
                            result.outboundAudioRtp.set(entry.id, data);
                            result.producerStreamMap.get(producerId).outboundAudioRtpId.push(entry.id);
                            this.processOutboundProducerAudioStats(producerId, overallStatsForProducer, data);
                        }
                    }
                    else {
                        // console.log("Unknown Outbound-rtp mediatype", entry);
                    }
                    break;
                }
                case 'inbound-rtp': {
                    const rtpStreamStats = entry;
                    const consumerId = ownerId || this.inboundConsumerMap.get(entry.id);
                    if (rtpStreamStats.ssrc === 1234) {
                        break; // Bogus inbound-rtp
                    }
                    if (!this.overallConsumersStatsMap[consumerId]) {
                        this.overallConsumersStatsMap[consumerId] = {
                            totalVideoPacketsReceived: 0,
                            totalAudioPacketsReceived: 0,
                        };
                    }
                    const overallStatsForConsumer = this.overallConsumersStatsMap[consumerId];
                    if (['video', 'audio'].includes(rtpStreamStats.mediaType)) {
                        if (!this.inboundConsumerMap.has(entry.id)) {
                            // console.log('Inbound-RTP Stream found but no matching consumer exists!', entry.id);
                            result.staleConsumerStreamMap = true;
                            if (filtersSet) {
                                filtersSet.delete('inbound-rtp');
                            }
                            break;
                        }
                        if (!result.consumerStreamMap.has(consumerId)) {
                            result.consumerStreamMap.set(consumerId, {
                                inboundVideoRtpId: [],
                                inboundAudioRtpId: [],
                            });
                        }
                        const inboundData = {
                            bytesReceived: rtpStreamStats.bytesReceived,
                            packetsReceived: rtpStreamStats.packetsReceived,
                            packetsLost: rtpStreamStats.packetsLost,
                            jitter: rtpStreamStats.jitter,
                            nackCount: rtpStreamStats.nackCount,
                        };
                        if (rtpStreamStats.mediaType === 'video') {
                            if (rtpStreamStats.decoderImplementation === 'unknown') {
                                break;
                            }
                            const videoRtpStreamStats = rtpStreamStats;
                            const data = {
                                frameHeight: videoRtpStreamStats.frameHeight,
                                frameWidth: videoRtpStreamStats.frameWidth,
                                framesDecoded: videoRtpStreamStats.framesDecoded,
                                framesDropped: videoRtpStreamStats.framesDropped,
                                framesPerSecond: videoRtpStreamStats.framesPerSecond,
                                framesReceived: videoRtpStreamStats.framesReceived,
                                keyFramesDecoded: videoRtpStreamStats.keyFramesDecoded,
                                firCount: videoRtpStreamStats.firCount,
                                decoderImplementation: videoRtpStreamStats.decoderImplementation,
                                ...inboundData,
                            };
                            result.inboundVideoRtp.set(entry.id, data);
                            result.consumerStreamMap.get(consumerId).inboundVideoRtpId.push(entry.id);
                            this.processInboundConsumerVideoStats(consumerId, overallStatsForConsumer, data);
                        }
                        else if (rtpStreamStats.mediaType === 'audio') {
                            const audioStreamStats = rtpStreamStats;
                            const data = {
                                audioLevel: audioStreamStats.audioLevel,
                                concealedSampels: audioStreamStats.concealedSampels,
                                concealmentEvents: audioStreamStats.concealmentEvents,
                                jitterBufferDelay: audioStreamStats.jitterBufferDelay,
                                jitterBufferEmittedCount: audioStreamStats.jitterBufferEmittedCount,
                                totalAudioEnergy: audioStreamStats.totalAudioEnergy,
                                totalSamplesDuration: audioStreamStats.totalSamplesDuration,
                                totalSamplesReceived: audioStreamStats.totalSamplesReceived,
                                ...inboundData,
                            };
                            result.inboundAudioRtp.set(entry.id, data);
                            result.consumerStreamMap.get(consumerId).inboundAudioRtpId.push(entry.id);
                            this.processInboundConsumerAudioStats(consumerId, overallStatsForConsumer, data);
                        }
                    }
                    else {
                        // console.log("Unknown Inbound-rtp mediatype", entry);
                    }
                    break;
                }
                default:
                    break;
            }
        }
        result.outboundVideoRtp.forEach((value, key) => {
            value.remoteData = result.remoteInboundRtp.get(key);
        });
        result.outboundAudioRtp.forEach((value, key) => {
            value.remoteData = result.remoteInboundRtp.get(key);
        });
        if (result.candidatePair) {
            if (result.transport) {
                // result.transport.candidateStats = result.candidatePair;
                result.transport.totalRoundTripTime = result.candidatePair.totalRoundTripTime;
                result.transport.availableOutgoingBitrate = result.candidatePair.availableOutgoingBitrate;
                result.transport.roundTripTime = result.candidatePair.currentRoundTripTime;
            }
            else {
                result.transport = {
                    // candidateStats: result.candidatePair,
                    bytesReceived: result.candidatePair.bytesReceived,
                    bytesSent: result.candidatePair.bytesSent,
                    totalRoundTripTime: result.candidatePair.totalRoundTripTime,
                    availableOutgoingBitrate: result.candidatePair.availableOutgoingBitrate,
                    roundTripTime: result.candidatePair.currentRoundTripTime,
                };
            }
        }
        if (result.transport && !result.transport.roundTripTime) {
            // If we still dont have roundTripTime for the transport, get it from audio/video entries
            let rtt = 0;
            let totalRTT = 0;
            // Get the max RTT from all video/audio entries
            result.remoteInboundRtp.forEach((value, key) => {
                if (value.roundTripTime && value.roundTripTime > rtt) {
                    rtt = value.roundTripTime;
                    totalRTT = value.totalRoundTripTime;
                }
            });
            result.transport.roundTripTime = rtt;
            result.transport.totalRoundTripTime = totalRTT;
        }
        return result;
    }
    async getProducersReport(producers) {
        const producerPromises = producers.map((producer) => this.generateProducerStreamMap(producer, true));
        return producerPromises.length > 0 ? Promise.all(producerPromises) : undefined;
    }
    async getConsumersReport(consumers) {
        const consumerPromises = consumers.map((consumer) => this.generateConsumerStreamMap(consumer, true));
        return consumerPromises.length > 0 ? Promise.all(consumerPromises) : undefined;
    }
    // eslint-disable-next-line class-methods-use-this
    async getTransportReport(transport) {
        return transport.getStats();
    }
    async getProcessedStats(transport, consuming, producing) {
        const transportStats = (await this.getTransportReport(transport));
        const transportInfo = { producing, consuming, id: transport.id };
        const stat = transportStats;
        const result = this.parseRTCReport(stat, ['transport', 'candidate-pair', 'inbound-rtp', 'outbound-rtp', 'remote-inbound-rtp'], false, undefined, transportInfo);
        // console.log('transportStats', stat, 'consuming', consuming, transportStats, result);
        if (!result) {
            // result is undefined only if current maps are no longer valid, so generate new ones!
            // New maps would only be generated by the calling module so return undefined!
            return undefined;
        }
        const transportReport = {
            stats: result.transport,
            transportId: transport.id,
            consuming,
            producing,
        };
        const producerReport = result.staleProducerStreamMap
            ? undefined
            : this.getProducerStatsFromReport(result);
        const consumerReport = result.staleConsumerStreamMap
            ? undefined
            : this.getConsumerStatsFromReport(result);
        return {
            transportReport,
            producerReport,
            consumerReport,
        };
    }
    // eslint-disable-next-line class-methods-use-this
    getProducerStatsFromReport(report) {
        const producerReport = [];
        try {
            report.producerStreamMap.forEach((value, key) => {
                producerReport.push({
                    producerId: key,
                    videoStats: value.outboundVideoRtpId.map((id) => report.outboundVideoRtp.get(id)),
                    audioStats: value.outboundAudioRtpId.map((id) => report.outboundAudioRtp.get(id)),
                    appData: this.callStatsInstance.producers?.get(key)?.appData || null,
                });
            });
        }
        catch (error) {
            // eslint-disable-next-line no-console
            this.callStatsInstance.logger.error('callStats::measurements::getProducerStatsFromReport', {
                error: { reason: error.reason, message: error.message },
            });
        }
        return producerReport;
    }
    getConsumerStatsFromReport(report) {
        const consumerReport = [];
        try {
            report.consumerStreamMap.forEach((value, key) => {
                const { peerId, producerId } = this.consumerPeerIdMap.get(key);
                consumerReport.push({
                    consumerId: key,
                    peerId,
                    producerId,
                    videoStats: value.inboundVideoRtpId.map((id) => report.inboundVideoRtp.get(id)),
                    audioStats: value.inboundAudioRtpId.map((id) => report.inboundAudioRtp.get(id)),
                });
            });
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.error('getConsumersReport: ', error, report);
        }
        return consumerReport;
    }
    // eslint-disable-next-line class-methods-use-this
    async getUserLocation() {
        const promise = new Promise((resolve, reject) => {
            try {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition((position) => {
                        resolve(position);
                    });
                }
                else {
                    reject();
                }
            }
            catch (e) {
                reject(e);
            }
        });
        return promise;
    }
    // eslint-disable-next-line class-methods-use-this
    async getConnectivity(iceServers) {
        try {
            const config = {
                iceServers: iceServers || FALLBACK_ICE_SERVERS,
            };
            const hostPromise = new Promise((resolve, reject) => {
                try {
                    const test = new HostConnectivityTest(config);
                    test.addListener('done', resolve);
                    test.addListener('failed', () => { resolve({ connectivity: false }); });
                    test.start(2000);
                }
                catch (e) {
                    reject(e);
                }
            });
            const relayPromise = new Promise((resolve, reject) => {
                try {
                    const test = new RelayConnectivityTest(config);
                    test.addListener('done', resolve);
                    test.addListener('failed', () => { resolve({ connectivity: false }); });
                    test.start(2000);
                }
                catch (e) {
                    reject(e);
                }
            });
            const reflexivePromise = new Promise((resolve, reject) => {
                try {
                    const test = new ReflexiveConnectivityTest(config);
                    test.addListener('done', resolve);
                    test.addListener('failed', () => { resolve({ connectivity: false }); });
                    test.start(2000);
                }
                catch (e) {
                    reject(e);
                }
            });
            const [host, relay, reflexive] = await Promise.all([hostPromise, relayPromise, reflexivePromise]);
            // console.log("Connectivity:", host, relay, reflexive)
            return {
                host: host?.connectivity,
                relay: relay?.connectivity,
                reflexive: reflexive?.connectivity,
            };
        }
        catch {
            return {
                host: false,
                relay: false,
                reflexive: false,
            };
        }
    }
    // eslint-disable-next-line class-methods-use-this
    async getThroughput(iceServers) {
        try {
            const throughPutPromise = new Promise((resolve, reject) => {
                try {
                    const config = {
                        iceServers: iceServers || FALLBACK_ICE_SERVERS,
                    };
                    const test = new DataThroughputTest(config);
                    test.addListener('done', resolve);
                    test.addListener('failed', reject);
                    test.start(10000);
                }
                catch (e) {
                    reject(e);
                }
            });
            const results = (await throughPutPromise);
            // console.log("RESULTS: ", results);
            return {
                throughput: results.throughput,
                fractionalLoss: 0,
                RTT: results.RTT,
                jitter: 0,
                backendRTT: results.backendRTT,
            };
        }
        catch {
            return undefined;
        }
    }
    async getIPDetails() {
        try {
            if (!this.ipDetails) {
                this.ipDetails = await ipDetails.getIPDetails({ peerId: this.callStatsInstance?.peerId });
            }
            return this.ipDetails;
        }
        catch {
            return undefined;
        }
    }
    async getNetworkQuality(iceServers) {
        const [connectivity, throughput] = await Promise.all([
            this.getConnectivity(iceServers),
            this.getThroughput(iceServers),
        ]);
        const measurements = {
            connectivity,
            throughput: throughput?.throughput,
            fractionalLoss: throughput?.fractionalLoss,
            RTT: throughput?.RTT,
            jitter: throughput?.jitter,
            backendRTT: throughput?.backendRTT,
        };
        return measurements;
    }
    async getNetworkInfo(iceServers) {
        const [connectivity, throughput, ipDetails] = await Promise.all([
            this.getConnectivity(iceServers),
            this.getThroughput(iceServers),
            this.getIPDetails(),
        ]);
        // console.log(connectivity, throughput, ipDetails);
        const measurements = {
            ipDetails,
            effectiveNetworkType: navigator.connection?.effectiveType,
            location: ipDetails.loc
                ? parseIpLocation(ipDetails.loc)
                : undefined,
            turnConnectivity: connectivity
                ? connectivity.host || connectivity.relay || connectivity.reflexive
                : false,
            connectivity,
            throughput: throughput?.throughput,
            fractionalLoss: throughput?.fractionalLoss,
            RTT: throughput?.RTT,
            jitter: throughput?.jitter,
            backendRTT: throughput?.backendRTT,
        };
        // console.log("network measurements", measurements);
        return measurements;
    }
}
