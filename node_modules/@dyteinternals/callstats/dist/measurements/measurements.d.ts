import { types as MediaSoup } from '@dytesdk/mediasoup-client';
import * as MeasurementTypes from '../measurements/types';
import * as MajorTypes from '../types';
import { CallStats } from '..';
export declare const FALLBACK_ICE_SERVERS: MajorTypes.IceServerInfo[];
export declare function parseIpLocation(loc: string): MeasurementTypes.GeoLocation;
export interface ParsedProducerStats {
    outboundVideoRtpId: string[];
    outboundAudioRtpId: string[];
}
export interface ParsedConsumerStats {
    inboundVideoRtpId: string[];
    inboundAudioRtpId: string[];
}
export declare class ParsedRTCStats {
    transport: MeasurementTypes.WebRtcTransportStat;
    candidatePair: MeasurementTypes.IceCandidatePairStats;
    outboundVideoRtp: Map<string, MeasurementTypes.OutboundVideoStreamStats>;
    inboundVideoRtp: Map<string, MeasurementTypes.InboundVideoStreamStats>;
    outboundAudioRtp: Map<string, MeasurementTypes.OutboundAudioStreamStats>;
    inboundAudioRtp: Map<string, MeasurementTypes.InboundAudioStreamStats>;
    remoteInboundRtp: Map<string, MeasurementTypes.RemoteInboundStreamStats>;
    producerStreamMap: Map<string, ParsedProducerStats>;
    consumerStreamMap: Map<string, ParsedConsumerStats>;
    staleProducerStreamMap: boolean;
    staleConsumerStreamMap: boolean;
}
export declare abstract class Measurements {
    outboundProducerMap: Map<string, string>;
    inboundConsumerMap: Map<string, string>;
    consumerPeerIdMap: Map<string, {
        producerId: string;
        peerId: string;
    }>;
    overallProducingTransportsStatsMap: Record<string, {
        totalPacketsSent: number;
    }>;
    overallConsumingTransportsStatsMap: Record<string, {
        totalPacketsReceived: number;
    }>;
    overallConsumersStatsMap: Record<string, {
        totalVideoPacketsReceived: number;
        totalAudioPacketsReceived: number;
    }>;
    overallProducersStatsMap: Record<string, {
        totalVideoPacketsSent: number;
        totalAudioPacketsSent: number;
    }>;
    consumerIdsWithFreezedVideo: Set<string>;
    consumerIdsWithFreezedAudio: Set<string>;
    producerIdsWithFreezedVideo: Set<string>;
    producerIdsWithFreezedAudio: Set<string>;
    freezedProducingTransportIds: Set<string>;
    freezedConsumingTransportIds: Set<string>;
    ipDetails: MeasurementTypes.IPDetails;
    callStatsInstance: CallStats;
    registerProducer(producer: MediaSoup.Producer): Promise<void>;
    processInboundConsumerVideoStats(consumerId: string, overallStatsForConsumer: {
        totalVideoPacketsReceived: number;
        totalAudioPacketsReceived: number;
    }, streamStatsData: MeasurementTypes.InboundVideoStreamStats): void;
    processInboundConsumerAudioStats(consumerId: string, overallStatsForConsumer: {
        totalVideoPacketsReceived: number;
        totalAudioPacketsReceived: number;
    }, streamStatsData: MeasurementTypes.InboundAudioStreamStats): void;
    processOutboundProducerVideoStats(producerId: string, overallStatsForProducer: {
        totalVideoPacketsSent: number;
        totalAudioPacketsSent: number;
    }, streamStatsData: MeasurementTypes.OutboundVideoStreamStats): void;
    processOutboundProducerAudioStats(producerId: string, overallStatsForProducer: {
        totalVideoPacketsSent: number;
        totalAudioPacketsSent: number;
    }, streamStatsData: MeasurementTypes.OutboundAudioStreamStats): void;
    processProducingTransportStats(transportId: string, overallStatsForTransport: {
        totalPacketsSent: number;
    }, transportStatsData: MeasurementTypes.WebRtcTransportStat): void;
    processConsumingTransportStats(transportId: string, overallStatsForTransport: {
        totalPacketsReceived: number;
    }, streamStatsData: MeasurementTypes.WebRtcTransportStat): void;
    registerConsumer(consumer: MediaSoup.Consumer): Promise<void>;
    generateProducerStreamMap(producer: MediaSoup.Producer, parse?: boolean): Promise<MeasurementTypes.ProducerStatistics>;
    generateConsumerStreamMap(consumer: MediaSoup.Consumer, parse?: boolean): Promise<MeasurementTypes.ConsumerStatistics>;
    deregisterProducer(producer: MediaSoup.Producer): void;
    deregisterConsumer(consumer: MediaSoup.Consumer): void;
    protected parseRTCReport(report: RTCStatsReport, filters?: string[], onceOnly?: boolean, ownerId?: string, transportInfo?: {
        id: string;
        producing: boolean;
        consuming: boolean;
    }): ParsedRTCStats;
    getProducersReport(producers: MediaSoup.Producer[]): Promise<MeasurementTypes.ProducerStatistics[]>;
    getConsumersReport(consumers: MediaSoup.Consumer[]): Promise<MeasurementTypes.ConsumerStatistics[]>;
    getTransportReport(transport: MediaSoup.Transport): Promise<RTCStatsReport>;
    getProcessedStats(transport: MediaSoup.Transport, consuming: boolean, producing: boolean): Promise<MeasurementTypes.ProcessedStatsReport>;
    protected getProducerStatsFromReport(report: ParsedRTCStats): MeasurementTypes.ProducerStatistics[];
    protected getConsumerStatsFromReport(report: ParsedRTCStats): MeasurementTypes.ConsumerStatistics[];
    getUserLocation(): Promise<MeasurementTypes.GeoLocation>;
    getConnectivity(iceServers: MajorTypes.IceServerInfo[]): Promise<{
        host: boolean;
        relay: boolean;
        reflexive: boolean;
    }>;
    getThroughput(iceServers: MajorTypes.IceServerInfo[]): Promise<MeasurementTypes.ThroughputInformation>;
    getIPDetails(): Promise<MeasurementTypes.IPDetails>;
    getNetworkQuality(iceServers: MajorTypes.IceServerInfo[]): Promise<MeasurementTypes.NetworkQualityInformation>;
    getNetworkInfo(iceServers: MajorTypes.IceServerInfo[]): Promise<MeasurementTypes.NetworkInformation>;
}
