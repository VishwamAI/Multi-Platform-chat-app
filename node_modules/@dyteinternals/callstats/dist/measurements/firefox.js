import { Measurements, ParsedRTCStats, } from './measurements';
export default class FirefoxMeasurements extends Measurements {
    producerMap = new Map();
    consumerMap = new Map();
    async registerProducer(producer) {
        this.producerMap.set(producer.id, producer);
        await this.generateProducerStreamMap(producer);
        producer.observer.on('close', this.deregisterProducer.bind(this, producer));
    }
    async registerConsumer(consumer) {
        this.consumerMap.set(consumer.id, consumer);
        await this.generateConsumerStreamMap(consumer);
        this.consumerPeerIdMap.set(consumer.id, {
            producerId: consumer.producerId,
            peerId: consumer.appData.peerId,
        });
        consumer.observer.on('close', this.deregisterConsumer.bind(this, consumer));
    }
    async generateConsumerStreamMap(consumer, parse = false) {
        const stat = await consumer.getStats();
        // console.log("Consumer stats", stat);
        const report = this.parseRTCReport(stat, ['inbound-rtp'], false, consumer.id);
        const statsObj = [...report.consumerStreamMap.values()][0];
        const result = parse
            ? this.getConsumerStatsFromParsedConsumerStats(report, statsObj, consumer.id)
            : undefined;
        for (const entry of stat.values()) {
            switch (entry.type) {
                case 'inbound-rtp': {
                    this.inboundConsumerMap.set(entry.id, consumer.id);
                    break;
                }
                default:
                    break;
            }
        }
        // console.log("Inbound: ", this.inboundConsumerMap, stat, consumer);
        return result;
    }
    deregisterProducer(producer) {
        this.producerMap.delete(producer.id);
        this.outboundProducerMap.forEach((value, key) => {
            if (value === producer.id) {
                this.outboundProducerMap.delete(key);
            }
        });
    }
    deregisterConsumer(consumer) {
        this.consumerMap.delete(consumer.id);
        this.inboundConsumerMap.forEach((value, key) => {
            if (value === consumer.id) {
                this.inboundConsumerMap.delete(key);
            }
        });
        this.consumerPeerIdMap.delete(consumer.id);
    }
    parseRTCReport(report, filters = [], onceOnly = false, ownerId = undefined, transportInfo = undefined) {
        const stat = report;
        const result = new ParsedRTCStats();
        const filtersSet = filters.length ? new Set(filters) : undefined;
        for (const entry of stat.values()) {
            if (filtersSet) {
                if (filtersSet.size === 0) {
                    break;
                }
                else if (!filtersSet.has(entry.type)) {
                    // Entry not in filtersSet so skip it
                    // eslint-disable-next-line no-continue
                    continue;
                }
                else if (onceOnly) {
                    // Entry type in filters, take it
                    filtersSet.delete(entry.type); // Delete cuz its gonna be parsed
                }
            }
            switch (entry.type) {
                case 'candidate-pair': {
                    /**
                     * Note(ravindra-dyte):
                     * nominated is supported in Safari & Chrome whereas selected is supported in Firefox.
                     * However Safari & firefox use this file instead of measurements.tsx
                     */
                    if (entry.nominated === true || entry.selected === true) {
                        const candidateStats = entry;
                        const data = {
                            bytesReceived: candidateStats.bytesReceived,
                            bytesSent: candidateStats.bytesSent,
                            currentRoundTripTime: candidateStats.currentRoundTripTime,
                            totalRoundTripTime: candidateStats.totalRoundTripTime,
                            availableOutgoingBitrate: candidateStats.availableOutgoingBitrate,
                        };
                        result.candidatePair = data;
                        break;
                    }
                    break;
                }
                case 'transport': {
                    const transportStats = entry;
                    if (transportInfo) {
                        if (transportInfo.producing) {
                            if (!this.overallProducingTransportsStatsMap[transportInfo.id]) {
                                this.overallProducingTransportsStatsMap[transportInfo.id] = {
                                    totalPacketsSent: 0,
                                };
                            }
                        }
                        if (transportInfo.consuming) {
                            if (!this.overallConsumingTransportsStatsMap[transportInfo.id]) {
                                this.overallConsumingTransportsStatsMap[transportInfo.id] = {
                                    totalPacketsReceived: 0,
                                };
                            }
                        }
                    }
                    const data = {
                        bytesReceived: transportStats.bytesReceived,
                        bytesSent: transportStats.bytesSent,
                        packetsSent: transportStats.packetsSent,
                        packetsReceived: transportStats.packetsReceived,
                        dtlsCipher: transportStats.dtlsCipher,
                        dtlsState: transportStats.dtlsState,
                        iceRole: transportStats.iceRole,
                    };
                    result.transport = data;
                    if (transportInfo) {
                        if (transportInfo.producing) {
                            const overallStatsForTransport = this.overallProducingTransportsStatsMap[transportInfo.id];
                            this.processProducingTransportStats(transportInfo.id, overallStatsForTransport, data);
                        }
                        if (transportInfo.consuming) {
                            const overallStatsForTransport = this.overallConsumingTransportsStatsMap[transportInfo.id];
                            this.processConsumingTransportStats(transportInfo.id, overallStatsForTransport, data);
                        }
                    }
                    // There is only 1 transport entry, and so return here itself;
                    // return result;
                    break;
                }
                case 'remote-inbound-rtp': {
                    // Mediasoup apparently dosent implement RTCRemoteInboundRtpStreamStats
                    const rtpStreamStats = entry;
                    const data = {
                        jitter: rtpStreamStats.jitter,
                        fractionLost: rtpStreamStats.fractionLost,
                        roundTripTime: rtpStreamStats.roundTripTime,
                        roundTripTimeMeasurements: rtpStreamStats.roundTripTimeMeasurements,
                        totalRoundTripTime: rtpStreamStats.totalRoundTripTime,
                        packetsLost: rtpStreamStats.packetsLost,
                    };
                    result.remoteInboundRtp.set(rtpStreamStats.localId, data);
                    break;
                }
                case 'outbound-rtp': {
                    const rtpStreamStats = entry; // RTCOutboundRTPStreamStats?
                    const producerId = ownerId || this.outboundProducerMap.get(entry.id);
                    if (!this.overallProducersStatsMap[producerId]) {
                        this.overallProducersStatsMap[producerId] = {
                            totalVideoPacketsSent: 0,
                            totalAudioPacketsSent: 0,
                        };
                    }
                    const overallStatsForProducer = this.overallProducersStatsMap[producerId];
                    if (['video', 'audio'].includes(rtpStreamStats.mediaType)) {
                        if (!this.outboundProducerMap.has(entry.id)) {
                            // console.log('Outbound-RTP Stream found but no matching producer exists!', entry.id);
                            result.staleProducerStreamMap = true;
                            if (filtersSet) {
                                filtersSet.delete('outbound-rtp');
                            }
                            break;
                        }
                        if (!result.producerStreamMap.has(producerId)) {
                            result.producerStreamMap.set(producerId, {
                                outboundVideoRtpId: [],
                                outboundAudioRtpId: [],
                            });
                        }
                        const outboundData = {
                            bytesSent: rtpStreamStats.bytesSent,
                            packetsSent: rtpStreamStats.packetsSent,
                            nackCount: rtpStreamStats.nackCount,
                        };
                        if (rtpStreamStats.mediaType === 'video') {
                            if (rtpStreamStats.decoderImplementation === 'unknown') {
                                break;
                            }
                            const videoRtpStreamStats = rtpStreamStats;
                            const data = {
                                frameHeight: videoRtpStreamStats.frameHeight,
                                frameWidth: videoRtpStreamStats.frameWidth,
                                framesEncoded: videoRtpStreamStats.framesEncoded,
                                framesDropped: videoRtpStreamStats.framesDropped
                                    ? videoRtpStreamStats.framesDropped
                                    : videoRtpStreamStats.droppedFrames,
                                framesPerSecond: videoRtpStreamStats.framesPerSecond
                                    ? videoRtpStreamStats.framesPerSecond
                                    : videoRtpStreamStats.framerateMean,
                                framesSent: videoRtpStreamStats.framesSent,
                                keyFramesEncoded: videoRtpStreamStats.keyFramesEncoded,
                                firCount: videoRtpStreamStats.firCount,
                                encoderImplementation: videoRtpStreamStats.encoderImplementation,
                                hugeFramesSent: videoRtpStreamStats.hugeFramesSent,
                                pliCount: videoRtpStreamStats.pliCount,
                                qpSum: videoRtpStreamStats.qpSum,
                                qualityLimitationReason: videoRtpStreamStats.qualityLimitationReason,
                                qualityLimitationDurations: videoRtpStreamStats.qualityLimitationDurations,
                                qualityLimitationResolutionChanges: videoRtpStreamStats.qualityLimitationResolutionChanges,
                                totalEncodeTime: videoRtpStreamStats.totalEncodeTime,
                                totalPacketSendDelay: videoRtpStreamStats.totalEncodeTime,
                                retransmittedBytesSent: videoRtpStreamStats.retransmittedBytesSent,
                                retransmittedPacketsSent: videoRtpStreamStats.retransmittedPacketsSent,
                                ...outboundData,
                            };
                            result.outboundVideoRtp.set(entry.id, data);
                            result.producerStreamMap.get(producerId).outboundVideoRtpId.push(entry.id);
                            this.processOutboundProducerVideoStats(producerId, overallStatsForProducer, data);
                        }
                        else if (rtpStreamStats.mediaType === 'audio') {
                            const audioStreamStats = rtpStreamStats;
                            const data = {
                                retransmittedBytesSent: audioStreamStats.retransmittedBytesSent,
                                retransmittedPacketsSent: audioStreamStats.retransmittedPacketsSent,
                                ...outboundData,
                            };
                            result.outboundAudioRtp.set(entry.id, data);
                            result.producerStreamMap.get(producerId).outboundAudioRtpId.push(entry.id);
                            this.processOutboundProducerAudioStats(producerId, overallStatsForProducer, data);
                        }
                    }
                    else {
                        // console.log("Unknown Outbound-rtp mediatype", entry);
                    }
                    break;
                }
                case 'inbound-rtp': {
                    const rtpStreamStats = entry; // RTCInboundRTPStreamStats?
                    const consumerId = ownerId || this.inboundConsumerMap.get(entry.id);
                    if (!this.overallConsumersStatsMap[consumerId]) {
                        this.overallConsumersStatsMap[consumerId] = {
                            totalVideoPacketsReceived: 0,
                            totalAudioPacketsReceived: 0,
                        };
                    }
                    const overallStatsForConsumer = this.overallConsumersStatsMap[consumerId];
                    if (['video', 'audio'].includes(rtpStreamStats.mediaType)) {
                        if (!this.inboundConsumerMap.has(entry.id)) {
                            // console.log('Inbound-RTP Stream found but no matching consumer exists!', entry.id);
                            result.staleConsumerStreamMap = true;
                            if (filtersSet) {
                                filtersSet.delete('inbound-rtp');
                            }
                            break;
                        }
                        if (!result.consumerStreamMap.has(consumerId)) {
                            result.consumerStreamMap.set(consumerId, {
                                inboundVideoRtpId: [],
                                inboundAudioRtpId: [],
                            });
                        }
                        const inboundData = {
                            bytesReceived: rtpStreamStats.bytesReceived,
                            packetsReceived: rtpStreamStats.packetsReceived,
                            packetsLost: rtpStreamStats.packetsLost,
                            jitter: rtpStreamStats.jitter,
                            nackCount: rtpStreamStats.nackCount,
                        };
                        if (rtpStreamStats.mediaType === 'video') {
                            if (rtpStreamStats.decoderImplementation === 'unknown') {
                                break;
                            }
                            const videoRtpStreamStats = rtpStreamStats;
                            const data = {
                                frameHeight: videoRtpStreamStats.frameHeight,
                                frameWidth: videoRtpStreamStats.frameWidth,
                                framesDecoded: videoRtpStreamStats.framesDecoded,
                                framesDropped: videoRtpStreamStats.framesDropped
                                    ? videoRtpStreamStats.framesDropped
                                    : videoRtpStreamStats.droppedFrames,
                                framesPerSecond: videoRtpStreamStats.framesPerSecond
                                    ? videoRtpStreamStats.framesPerSecond
                                    : videoRtpStreamStats.framerateMean,
                                framesReceived: videoRtpStreamStats.framesReceived,
                                keyFramesDecoded: videoRtpStreamStats.keyFramesDecoded,
                                firCount: videoRtpStreamStats.firCount,
                                decoderImplementation: videoRtpStreamStats.decoderImplementation,
                                ...inboundData,
                            };
                            result.inboundVideoRtp.set(entry.id, data);
                            result.consumerStreamMap.get(consumerId).inboundVideoRtpId.push(entry.id);
                            this.processInboundConsumerVideoStats(consumerId, overallStatsForConsumer, data);
                        }
                        else if (rtpStreamStats.mediaType === 'audio') {
                            const audioStreamStats = rtpStreamStats;
                            const data = {
                                audioLevel: audioStreamStats.audioLevel,
                                concealedSampels: audioStreamStats.concealedSampels,
                                concealmentEvents: audioStreamStats.concealmentEvents,
                                jitterBufferDelay: audioStreamStats.jitterBufferDelay,
                                jitterBufferEmittedCount: audioStreamStats.jitterBufferEmittedCount,
                                totalAudioEnergy: audioStreamStats.totalAudioEnergy,
                                totalSamplesDuration: audioStreamStats.totalSamplesDuration,
                                totalSamplesReceived: audioStreamStats.totalSamplesReceived,
                                ...inboundData,
                            };
                            result.inboundAudioRtp.set(entry.id, data);
                            result.consumerStreamMap.get(consumerId).inboundAudioRtpId.push(entry.id);
                            this.processInboundConsumerAudioStats(consumerId, overallStatsForConsumer, data);
                        }
                    }
                    else {
                        // console.log("Unknown Inbound-rtp mediatype", entry);
                    }
                    break;
                }
                default:
                    break;
            }
        }
        result.outboundVideoRtp.forEach((value, key) => {
            value.remoteData = result.remoteInboundRtp.get(key);
        });
        result.outboundAudioRtp.forEach((value, key) => {
            value.remoteData = result.remoteInboundRtp.get(key);
        });
        if (result.candidatePair) {
            if (result.transport) {
                // console.log("Transsport exists")
                // result.transport.candidateStats = result.candidatePair;
                result.transport.bytesReceived = result.candidatePair.bytesReceived;
                result.transport.bytesSent = result.candidatePair.bytesSent;
                result.transport.totalRoundTripTime = result.candidatePair.totalRoundTripTime;
                result.transport.availableOutgoingBitrate = result.candidatePair.availableOutgoingBitrate;
                result.transport.roundTripTime = result.candidatePair.currentRoundTripTime;
            }
            else {
                // console.log("Creating transport entry ")
                result.transport = {
                    // candidateStats: result.candidatePair,
                    bytesReceived: result.candidatePair.bytesReceived,
                    bytesSent: result.candidatePair.bytesSent,
                    totalRoundTripTime: result.candidatePair.totalRoundTripTime,
                    availableOutgoingBitrate: result.candidatePair.availableOutgoingBitrate,
                    roundTripTime: result.candidatePair.currentRoundTripTime,
                };
            }
        }
        if (result.transport && !result.transport.roundTripTime) {
            // If we still dont have roundTripTime for the transport, get it from audio/video entries
            let rtt = 0;
            let totalRTT = 0;
            // Get the max RTT from all video/audio entries
            result.remoteInboundRtp.forEach((value, key) => {
                if (value.roundTripTime && value.roundTripTime > rtt) {
                    rtt = value.roundTripTime;
                    totalRTT = value.totalRoundTripTime;
                }
            });
            result.transport.roundTripTime = rtt;
            result.transport.totalRoundTripTime = totalRTT;
        }
        return result;
    }
    getProducerStatsFromReport(report) {
        const producerReport = [];
        try {
            report.producerStreamMap.forEach((value, key) => {
                const producer = this.producerMap.get(key);
                const track = producer.track.getSettings();
                const videoStats = value.outboundVideoRtpId.map((id) => {
                    const val = report.outboundVideoRtp.get(id);
                    if (!val.frameHeight) {
                        val.frameHeight = track.height;
                        val.frameWidth = track.width;
                        val.framesPerSecond = track.frameRate;
                    }
                    return val;
                });
                const entry = {
                    producerId: key,
                    videoStats,
                    audioStats: value.outboundAudioRtpId.map((id) => report.outboundAudioRtp.get(id)),
                };
                producerReport.push(entry);
            });
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.error('getProducersReport: ', error, report);
        }
        return producerReport;
    }
    getConsumerStatsFromParsedConsumerStats(report, stats, consumerId) {
        let consumerReport;
        try {
            const { peerId, producerId } = this.consumerPeerIdMap.get(consumerId);
            const videoStats = stats?.inboundVideoRtpId.map((id) => {
                const consumer = this.consumerMap.get(consumerId);
                const track = consumer.track.getSettings();
                const val = report.inboundVideoRtp.get(id);
                if (!val.frameHeight) {
                    val.frameHeight = track.height;
                    val.frameWidth = track.width;
                    val.framesPerSecond = track.frameRate;
                }
                return val;
            });
            consumerReport = {
                consumerId,
                peerId,
                producerId,
                videoStats,
                audioStats: stats?.inboundAudioRtpId.map((id) => report.inboundAudioRtp.get(id)),
            };
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.error('getConsumerStatsFromParsedConsumerStats: ', error, report);
        }
        return consumerReport;
    }
    getConsumerStatsFromReport(report) {
        const consumerReport = [];
        try {
            report.consumerStreamMap.forEach((value, key) => {
                consumerReport.push(this.getConsumerStatsFromParsedConsumerStats(report, value, key));
            });
        }
        catch (error) {
            // eslint-disable-next-line no-console
            console.error('getConsumerStatsFromReport: ', error, report);
        }
        return consumerReport;
    }
}
