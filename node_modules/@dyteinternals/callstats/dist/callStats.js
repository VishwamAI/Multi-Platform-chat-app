var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import * as EventTypes from './events/types';
import EventHandler from './events/events';
import * as Types from './types';
import { MediaDeviceType } from './types';
import SQSConnector from './connectors/pubSubConnectors/sqs';
import * as Measurements from './measurements/measurements';
import ChromeMeasurements from './measurements/chrome';
import SafariMeasurements from './measurements/safari';
import FirefoxMeasurements from './measurements/firefox';
import { CatchClass, CatchFunction } from './errorHandling';
const mainLogger = console;
let CallStats = class CallStats {
    eventHandler;
    measurements;
    producingTransport;
    consumingTransport;
    producers = new Map();
    consumers = new Map();
    iceServers;
    connectionInfoPromise;
    pingStatsTimeout;
    logger;
    env;
    peerId;
    consumerSharedMediaStatesMap = new Map();
    currentUserMediaStates = {};
    constructor(backendUrl = 'https://api.testingv3.dyte.in', engineName = 'Blink', env = Types.ClientEnvType.PRODUCTION, flags, logger, peerId) {
        this.env = env;
        this.logger = logger;
        this.peerId = peerId;
        // this.logger = console;
        const connection = new SQSConnector(env, flags.ingestionLayerDetails, logger);
        this.eventHandler = new EventHandler(connection);
        this.logger.debug('callStats::engineName: ', { engineName });
        switch (engineName) {
            case 'Blink':
                this.measurements = new ChromeMeasurements();
                break;
            case 'Gecko':
                this.measurements = new FirefoxMeasurements();
                break;
            case 'WebKit':
                this.measurements = new SafariMeasurements();
                break;
            default:
                throw (Error(`Unknown engineName! ${engineName}`));
        }
        this.measurements.callStatsInstance = this;
        this.registerProducer = this.registerProducer.bind(this);
        this.registerConsumer = this.registerConsumer.bind(this);
        this.measurements.getIPDetails().then((e) => {
            if (e) {
                const obj = {
                    ...e,
                };
                if (e.loc) {
                    obj.loc = Measurements.parseIpLocation(e.loc);
                }
                this.eventHandler.emit('initialized', obj);
            }
        });
    }
    authenticate(authPayload) {
        this.eventHandler.connection.authenticate(authPayload);
    }
    registerIceServers(servers) {
        this.iceServers = servers;
    }
    registerConsumer(consumer) {
        if (!this.consumerSharedMediaStatesMap.has(consumer.id)) {
            this.consumerSharedMediaStatesMap.set(consumer.id, {});
        }
        this.consumers.set(consumer.id, consumer);
        this.measurements.registerConsumer(consumer);
        this.logger.debug('callStats::registerConsumer', { consumerId: consumer.id, consumerkind: consumer.kind, isScreenShare: !!consumer.appData?.screenShare });
        consumer.observer.on('close', this.deRegisterConsumer.bind(this, consumer));
    }
    registerProducer(producer) {
        this.producers.set(producer.id, producer);
        this.measurements.registerProducer(producer);
        this.logger.debug('callStats::registerProducer', { producerId: producer.id, producerKind: producer.kind, isScreenShare: !!producer.appData?.screenShare });
        producer.observer.on('close', this.deRegisterProducer.bind(this, producer));
    }
    sendConsumerSharedMediaStateEvent(consumerId, statusObj) {
        if (!this.consumerSharedMediaStatesMap.has(consumerId)) {
            this.consumerSharedMediaStatesMap.set(consumerId, {});
        }
        const currentStatusObj = this.consumerSharedMediaStatesMap.get(consumerId);
        this.consumerSharedMediaStatesMap.set(consumerId, Object.assign(currentStatusObj, statusObj));
    }
    registerProducingTransport(transport) {
        this.producingTransport = transport;
        transport.observer.on('close', this.disconnectProducingTransport.bind(this, transport));
        transport.observer.on('disconnect', this.disconnectProducingTransport.bind(this, transport));
        const existingProducers = Array.from(
        // eslint-disable-next-line no-underscore-dangle
        transport._producers?.values() || []);
        existingProducers.forEach((producer) => {
            this.registerProducer(producer);
        });
        transport.observer.on('newproducer', this.registerProducer);
    }
    registerConsumingTransport(transport) {
        this.consumingTransport = transport;
        transport.observer.on('close', this.disconnectConsumingTransport.bind(this, transport));
        transport.observer.on('disconnect', this.disconnectConsumingTransport.bind(this, transport));
        const existingConsumers = Array.from(
        // eslint-disable-next-line no-underscore-dangle
        transport._consumers?.values() || []);
        existingConsumers.forEach((consumer) => {
            this.registerConsumer(consumer);
        });
        transport.observer.on('newconsumer', this.registerConsumer);
    }
    deRegisterConsumer(consumer) {
        this.consumers.delete(consumer.id);
    }
    deRegisterProducer(producer) {
        this.producers.delete(producer.id);
    }
    disconnectConsumingTransport() {
        this.consumingTransport = undefined;
    }
    disconnectProducingTransport() {
        this.producingTransport = undefined;
    }
    callEvent(entry) {
        this.eventHandler.callEvent(entry);
    }
    sendPreCallTestBeginEvent() {
        this.connectionInfoPromise = this.measurements.getNetworkInfo(this.iceServers);
        this.eventHandler.callEvent({
            event: EventTypes.Event.PRECALL_TEST_BEGIN,
            timestamp: new Date(),
        });
        if (this.connectionInfoPromise) {
            this.connectionInfoPromise.then((e) => {
                this.eventHandler.callEvent({
                    event: EventTypes.Event.PRECALL_TEST_COMPLETE,
                    metaData: {
                        connectionInfo: e,
                    },
                    timestamp: new Date(),
                });
            });
        }
    }
    sendScreenShareToggleEvent(on, ssrc) {
        this.currentUserMediaStates.screen = on;
        this.eventHandler.callEvent({
            event: on
                ? EventTypes.Event.SCREENSHARE_STARTED
                : EventTypes.Event.SCREENSHARE_STOPPED,
            metaData: {
                ssrc,
            },
            timestamp: new Date(),
        });
    }
    sendScreenShareRequestedEvent() {
        this.eventHandler.callEvent({
            event: EventTypes.Event.SCREENSHARE_START_REQUESTED,
            timestamp: new Date(),
        });
    }
    sendActiveSpeakerEvent(peerId) {
        this.eventHandler.callEvent({
            event: EventTypes.Event.DOMINANT_SPEAKER,
            metaData: {
                peerId,
            },
            timestamp: new Date(),
        });
    }
    devices(deviceType, deviceList) {
        this.eventHandler.callEvent({
            event: (deviceType === MediaDeviceType.AUDIO && EventTypes.Event.AUDIO_DEVICES_UPDATES)
                || (deviceType === MediaDeviceType.VIDEO && EventTypes.Event.VIDEO_DEVICES_UPDATES)
                || (deviceType === MediaDeviceType.SPEAKER && EventTypes.Event.SPEAKER_DEVICES_UPDATES),
            metaData: {
                deviceList,
            },
            timestamp: new Date(),
        });
    }
    selectedDevice(deviceType, device) {
        this.eventHandler.callEvent({
            event: (deviceType === MediaDeviceType.AUDIO && EventTypes.Event.SELECTED_MICROHPONE_UPDATE)
                || (deviceType === MediaDeviceType.VIDEO && EventTypes.Event.SELECTED_CAMERA_UPDATE)
                || (deviceType === MediaDeviceType.SPEAKER && EventTypes.Event.SELECTED_SPEAKER_UPDATE),
            metaData: {
                device,
            },
            timestamp: new Date(),
        });
    }
    mediaPermission(deviceType, permission) {
        this.eventHandler.callEvent({
            event: EventTypes.Event.MEDIA_PERMISSION,
            metaData: {
                deviceType,
                permission,
            },
            timestamp: new Date(),
        });
    }
    mediaPlaybackFailed(deviceType) {
        this.eventHandler.callEvent({
            event: (deviceType === MediaDeviceType.AUDIO && EventTypes.Event.AUDIO_PLAY_FAILED)
                || (deviceType === MediaDeviceType.VIDEO && EventTypes.Event.VIDEO_PLAY_FAILED),
            metaData: {
                deviceType,
            },
            timestamp: new Date(),
        });
    }
    mediaTrackMuted(deviceType) {
        this.eventHandler.callEvent({
            event: (deviceType === MediaDeviceType.AUDIO && EventTypes.Event.AUDIO_TRACK_MUTED)
                || (deviceType === MediaDeviceType.VIDEO && EventTypes.Event.VIDEO_TRACK_MUTED),
            metaData: {
                deviceType,
            },
            timestamp: new Date(),
        });
    }
    tabChanged(isMeetingsTabActive) {
        this.eventHandler.callEvent({
            event: EventTypes.Event.TAB_CHANGE,
            metaData: { isMeetingsTabActive },
            timestamp: new Date(),
        });
    }
    browserBackgrounded() {
        this.eventHandler.callEvent({
            event: EventTypes.Event.BROWSER_BACKGROUNDED,
            timestamp: new Date(),
        });
    }
    browserForegrounded() {
        this.eventHandler.callEvent({
            event: EventTypes.Event.BROWSER_FOREGROUNDED,
            timestamp: new Date(),
        });
    }
    legacySwitch(on) {
        this.eventHandler.callEvent({
            event: EventTypes.Event.LEGACY_SWITCH,
            metadata: { on },
            timestamp: new Date(),
        });
    }
    async getPreCallTestResults() {
        return this.connectionInfoPromise;
    }
    sendCallJoinBeginEvent(peerMetaData) {
        peerMetaData = {
            ...peerMetaData,
            meetingEnv: this.env,
        };
        peerMetaData.deviceInfo = {
            ...peerMetaData.deviceInfo,
            userAgent: navigator.userAgent,
            cpus: navigator.hardwareConcurrency,
            memory: navigator.deviceMemory,
        };
        this.eventHandler.callEvent({
            event: EventTypes.Event.CALL_JOIN_BEGIN,
            metaData: {
                peerMetaData,
            },
            timestamp: new Date(),
        });
    }
    sendNetworkQualityTestBeginEvent(regionalInformations) {
        this.eventHandler.callEvent({
            event: EventTypes.Event.NET_QUALITY_TEST_BEGIN,
            timestamp: new Date(),
        });
        // eslint-disable-next-line no-async-promise-executor
        const promise = new Promise(async (resolve, reject) => {
            // For every entry in regionalInformations, run a network quality test
            const regionData = [];
            try {
                // console.log('regionalInformations', regionalInformations);
                for (const e of regionalInformations) {
                    // console.log('=>', e);
                    try {
                        if (e.iceServers && e.iceServers.length > 0) {
                            // eslint-disable-next-line no-await-in-loop
                            const results = await this.measurements.getNetworkQuality(e.iceServers);
                            regionData.push({
                                ...e,
                                networkResults: results,
                            });
                        }
                    }
                    catch (e) {
                        // eslint-disable-next-line no-console
                        console.warn('Error handling ', e);
                    }
                }
                resolve({
                    regionData,
                });
            }
            catch (e) {
                // eslint-disable-next-line no-console
                console.warn('Error in callstats, ', e);
                reject(e);
            }
        });
        promise.then((e) => {
            this.eventHandler.callEvent({
                event: EventTypes.Event.NET_QUALITY_TEST_END,
                timestamp: new Date(),
                metaData: e,
            });
        });
    }
    sendWebSocketConnectedEvent() {
        this.eventHandler.callEvent({
            event: EventTypes.Event.WEBSOCKET_CONNECTED,
            timestamp: new Date(),
        });
    }
    sendTransportConnectedEvent() {
        this.eventHandler.callEvent({
            event: EventTypes.Event.TRANSPORT_CONNECTED,
            timestamp: new Date(),
        });
    }
    sendAudioToggleEvent(on) {
        this.currentUserMediaStates.audio = on;
        let event;
        if (!on) {
            event = EventTypes.Event.AUDIO_OFF;
        }
        else {
            event = EventTypes.Event.AUDIO_ON;
        }
        this.eventHandler.callEvent({
            event,
            timestamp: new Date(),
        });
    }
    sendVideoToggleEvent(on) {
        this.currentUserMediaStates.video = on;
        let event;
        if (!on) {
            event = EventTypes.Event.VIDEO_OFF;
        }
        else {
            event = EventTypes.Event.VIDEO_ON;
        }
        this.eventHandler.callEvent({
            event,
            timestamp: new Date(),
        });
    }
    sendParticipantRoleToggleEvent(role) {
        this.eventHandler.callEvent({
            event: EventTypes.Event.PARTICIPANT_ROLE,
            timestamp: new Date(),
            metaData: role,
        });
    }
    startPingStats(interval = 7000) {
        this.sendPingStatsEvent(false);
        this.pingStatsTimeout = setInterval(this.sendPingStatsEvent.bind(this), interval);
    }
    stopPingStats() {
        clearInterval(this.pingStatsTimeout);
    }
    async sendPingStatsEvent(optimize = true) {
        let proReport;
        let conReport;
        if (this.producingTransport) {
            proReport = await this.measurements.getProcessedStats(this.producingTransport, false, true);
            if (!proReport || !proReport?.producerReport) {
                // Its undefined if and only if producer/consumer rtp maps are no longer valid!,
                // so generate fresh
                this.logger.debug('callStats::sendPingStatsEvent::staleProducingTransport', { disclaimer: 'Stale producer? Regenerating Stream Maps!' });
                const report = await this.measurements.getProducersReport([...this.producers.values()]);
                if (proReport && report) {
                    proReport.producerReport = report;
                }
                else {
                    proReport = await this.measurements.getProcessedStats(this.producingTransport, false, true);
                    if (!proReport || !proReport?.producerReport) {
                        this.logger.debug('callStats::sendPingStatsEvent::noProducingTransportReport', { disclaimer: 'Stream maps invalid despite regenerating!' });
                        // This shouldn't happen, lets just skip for this ping event
                        // cuz this can only happen if things changed during this the above await calls
                        // return;
                    }
                }
            }
            // console.log("ProducerReport: ", proReport);
        }
        if (this.consumingTransport) {
            conReport = await this.measurements.getProcessedStats(this.consumingTransport, true, false);
            if (!conReport || !conReport.consumerReport) {
                // Its undefined if and only if producer/consumer rtp maps are no longer valid!,
                // so generate fresh
                this.logger.debug('callStats::sendPingStatsEvent::staleConsumingTransport', { disclaimer: 'Stale consumer? Regenerating Stream Maps!' });
                const report = await this.measurements.getConsumersReport([...this.consumers.values()]);
                if (conReport && report) {
                    conReport.consumerReport = report;
                }
                else {
                    conReport = await this.measurements.getProcessedStats(this.consumingTransport, true, false);
                    if (!conReport || !conReport.consumerReport) {
                        this.logger.debug('callStats::sendPingStatsEvent::noConsumingTransportReport', { disclaimer: 'Stream maps invalid despite regenerating!' });
                        // This shouldn't happen, lets just skip for this ping event
                        // cuz this can only happen if things changed during this the above await calls
                        // return;
                    }
                }
            }
            // console.log("ConsumerReport: ", conReport);
        }
        const metaData = {
            producingTransportStats: proReport ? proReport?.transportReport : undefined,
            consumingTransportStats: conReport ? conReport?.transportReport : undefined,
            producerStats: [].concat(proReport?.producerReport || [])
                .concat(conReport?.producerReport || []),
            consumerStats: [].concat(conReport?.consumerReport || [])
                .concat(proReport?.consumerReport || []),
        };
        if (optimize && metaData.producerStats.length === 0 && metaData.consumerStats.length === 0) {
            return;
        }
        this.eventHandler.callEvent({
            event: EventTypes.Event.PING_STAT,
            metaData,
            timestamp: new Date(),
        });
    }
    sendDisconnectEvent() {
        this.eventHandler.callEvent({
            event: EventTypes.Event.DISCONNECT,
            timestamp: new Date(),
        });
    }
    sendReconnectEvent() {
        this.eventHandler.callEvent({
            event: EventTypes.Event.RECONNECT_ATTEMPT,
            timestamp: new Date(),
        });
    }
};
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "authenticate", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "registerIceServers", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "registerConsumer", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "registerProducer", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "sendConsumerSharedMediaStateEvent", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "registerProducingTransport", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "registerConsumingTransport", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "deRegisterConsumer", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "deRegisterProducer", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "disconnectConsumingTransport", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "disconnectProducingTransport", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "sendPreCallTestBeginEvent", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "sendScreenShareToggleEvent", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "sendScreenShareRequestedEvent", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "sendActiveSpeakerEvent", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "devices", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "selectedDevice", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "mediaPermission", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "mediaPlaybackFailed", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "mediaTrackMuted", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "tabChanged", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "browserBackgrounded", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "browserForegrounded", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "legacySwitch", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "getPreCallTestResults", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "sendCallJoinBeginEvent", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "sendNetworkQualityTestBeginEvent", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "sendWebSocketConnectedEvent", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "sendTransportConnectedEvent", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "sendAudioToggleEvent", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "sendVideoToggleEvent", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "sendParticipantRoleToggleEvent", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "startPingStats", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "stopPingStats", null);
__decorate([
    CatchFunction(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats.prototype, "sendPingStatsEvent", null);
CallStats = __decorate([
    CatchClass(TypeError, (err, ctx) => mainLogger.error(ctx, err))
], CallStats);
export default CallStats;
// const abc = new CallStats();
// abc.callEvent({
//     event: EventTypes.Event.CALL_JOIN_BEGIN,
//     metaData: {
//         cdef: 123123,
//     },
//     timestamp: new Date()
// })
// const abc = new CallStats();
// abc.sendCallJoinBeginEvent({abc : PeerMetaData} : CallJoinData)
