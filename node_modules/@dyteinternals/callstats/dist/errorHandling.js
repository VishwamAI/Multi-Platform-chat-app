function handleError(ctx, errorType, handler, error) {
    // Check if error is instance of given error type
    if (typeof handler === 'function' && error instanceof errorType) {
        // Run handler with error object and class context
        handler.call(null, error, ctx);
    }
    else {
        // Throw error further
        // Next decorator in chain can catch it
        throw error;
    }
}
function generateDescriptor(descriptor, errorType, handler) {
    // Save a reference to the original method
    const originalMethod = descriptor.value;
    // Rewrite original method with try/catch wrapper
    // eslint-disable-next-line func-names
    descriptor.value = function (...args) {
        try {
            const result = originalMethod.apply(this, args);
            // Check if method is asynchronous
            if (result && result instanceof Promise) {
                // Return promise
                return result.catch((error) => {
                    handleError(this, errorType, handler, error);
                });
            }
            // Return actual result
            return result;
        }
        catch (error) {
            handleError(this, errorType, handler, error);
        }
        return null;
    };
    return descriptor;
}
export const CatchFunction = (errorType, handler) => (target, propertyKey, descriptor) => {
    // Save a reference to the original method
    const originalMethod = descriptor.value;
    // Rewrite original method with try/catch wrapper
    // eslint-disable-next-line func-names
    descriptor.value = function (...args) {
        try {
            const result = originalMethod.apply(this, args);
            // Check if method is asynchronous
            if (result && result instanceof Promise) {
                // Return promise
                return result.catch((error) => {
                    handleError(this, errorType, handler, error);
                });
            }
            // Return actual result
            return result;
        }
        catch (error) {
            handleError(this, errorType, handler, error);
        }
        return null;
    };
    return descriptor;
};
export const CatchAll = (handler) => CatchFunction(Error, handler);
// Decorator factory function
export const CatchClass = (errorType, handler) => (target, propertyKey, descriptor) => {
    // Method decorator
    if (descriptor) {
        return generateDescriptor(descriptor, errorType, handler);
    }
    // Class decorator
    // Iterate over class properties except constructor
    for (const propertyName of Reflect.ownKeys(target.prototype).filter((prop) => prop !== 'constructor')) {
        const desc = Object.getOwnPropertyDescriptor(target.prototype, propertyName);
        const isMethod = desc.value instanceof Function;
        // eslint-disable-next-line no-continue
        if (!isMethod)
            continue;
        Object.defineProperty(target.prototype, propertyName, generateDescriptor(desc, errorType, handler));
    }
    return undefined;
};
