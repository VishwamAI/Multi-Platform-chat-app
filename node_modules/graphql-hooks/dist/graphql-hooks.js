(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('events')) :
typeof define === 'function' && define.amd ? define(['exports', 'react', 'events'], factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.GraphQLHooks = {}, global.React, global.EventEmitter));
}(this, (function (exports, React, EventEmitter) { 'use strict';

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var EventEmitter__default = /*#__PURE__*/_interopDefaultLegacy(EventEmitter);

const ClientContext = React__default['default'].createContext(null);
ClientContext.displayName = "ClientContext";

/**
 * Used to mark a
 * [React Native `File` substitute]{@link ReactNativeFileSubstitute}
 * in an object tree for [`extractFiles`]{@link extractFiles}. Itâ€™s too risky to
 * assume all objects with `uri`, `type` and `name` properties are files to
 * extract.
 * @kind class
 * @name ReactNativeFile
 * @param {ReactNativeFileSubstitute} file A [React Native](https://reactnative.dev) [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) substitute.
 * @example <caption>Ways to `import`.</caption>
 * ```js
 * import { ReactNativeFile } from 'extract-files';
 * ```
 *
 * ```js
 * import ReactNativeFile from 'extract-files/public/ReactNativeFile.js';
 * ```
 * @example <caption>Ways to `require`.</caption>
 * ```js
 * const { ReactNativeFile } = require('extract-files');
 * ```
 *
 * ```js
 * const ReactNativeFile = require('extract-files/public/ReactNativeFile.js');
 * ```
 * @example <caption>An extractable file in [React Native](https://reactnative.dev).</caption>
 * ```js
 * const file = new ReactNativeFile({
 *   uri: uriFromCameraRoll,
 *   name: 'a.jpg',
 *   type: 'image/jpeg',
 * });
 * ```
 */

var ReactNativeFile_1 = class ReactNativeFile {
  constructor({
    uri,
    name,
    type
  }) {
    this.uri = uri;
    this.name = name;
    this.type = type;
  }

};

/**
 * Checks if a value is an [extractable file]{@link ExtractableFile}.
 * @kind function
 * @name isExtractableFile
 * @type {ExtractableFileMatcher}
 * @param {*} value Value to check.
 * @returns {boolean} Is the value an [extractable file]{@link ExtractableFile}.
 * @example <caption>Ways to `import`.</caption>
 * ```js
 * import { isExtractableFile } from 'extract-files';
 * ```
 *
 * ```js
 * import isExtractableFile from 'extract-files/public/isExtractableFile.js';
 * ```
 * @example <caption>Ways to `require`.</caption>
 * ```js
 * const { isExtractableFile } = require('extract-files');
 * ```
 *
 * ```js
 * const isExtractableFile = require('extract-files/public/isExtractableFile.js');
 * ```
 */


var isExtractableFile = function isExtractableFile(value) {
  return typeof File !== 'undefined' && value instanceof File || typeof Blob !== 'undefined' && value instanceof Blob || value instanceof ReactNativeFile_1;
};

/**
 * Clones a value, recursively extracting
 * [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File),
 * [`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob) and
 * [`ReactNativeFile`]{@link ReactNativeFile} instances with their
 * [object paths]{@link ObjectPath}, replacing them with `null`.
 * [`FileList`](https://developer.mozilla.org/en-US/docs/Web/API/Filelist) instances
 * are treated as [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)
 * instance arrays.
 * @kind function
 * @name extractFiles
 * @param {*} value Value (typically an object tree) to extract files from.
 * @param {ObjectPath} [path=''] Prefix for object paths for extracted files.
 * @param {ExtractableFileMatcher} [isExtractableFile=isExtractableFile] The function used to identify extractable files.
 * @returns {ExtractFilesResult} Result.
 * @example <caption>Ways to `import`.</caption>
 * ```js
 * import { extractFiles } from 'extract-files';
 * ```
 *
 * ```js
 * import extractFiles from 'extract-files/public/extractFiles.js';
 * ```
 * @example <caption>Ways to `require`.</caption>
 * ```js
 * const { extractFiles } = require('extract-files');
 * ```
 *
 * ```js
 * const extractFiles = require('extract-files/public/extractFiles.js');
 * ```
 * @example <caption>Extract files from an object.</caption>
 * For the following:
 *
 * ```js
 * const file1 = new File(['1'], '1.txt', { type: 'text/plain' });
 * const file2 = new File(['2'], '2.txt', { type: 'text/plain' });
 * const value = {
 *   a: file1,
 *   b: [file1, file2],
 * };
 *
 * const { clone, files } = extractFiles(value, 'prefix');
 * ```
 *
 * `value` remains the same.
 *
 * `clone` is:
 *
 * ```json
 * {
 *   "a": null,
 *   "b": [null, null]
 * }
 * ```
 *
 * `files` is a [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) instance containing:
 *
 * | Key     | Value                        |
 * | :------ | :--------------------------- |
 * | `file1` | `['prefix.a', 'prefix.b.0']` |
 * | `file2` | `['prefix.b.1']`             |
 */


var extractFiles = function extractFiles(value, path = '', isExtractableFile$1 = isExtractableFile) {
  // Map of extracted files and their object paths within the input value.
  const files = new Map(); // Map of arrays and objects recursed within the input value and their clones,
  // for reusing clones of values that are referenced multiple times within the
  // input value.

  const clones = new Map();
  /**
   * Recursively clones the value, extracting files.
   * @kind function
   * @name extractFiles~recurse
   * @param {*} value Value to extract files from.
   * @param {ObjectPath} path Prefix for object paths for extracted files.
   * @param {Set} recursed Recursed arrays and objects for avoiding infinite recursion of circular references within the input value.
   * @returns {*} Clone of the value with files replaced with `null`.
   * @ignore
   */

  function recurse(value, path, recursed) {
    let clone = value;

    if (isExtractableFile$1(value)) {
      clone = null;
      const filePaths = files.get(value);
      filePaths ? filePaths.push(path) : files.set(value, [path]);
    } else {
      const isList = Array.isArray(value) || typeof FileList !== 'undefined' && value instanceof FileList;
      const isObject = value && value.constructor === Object;

      if (isList || isObject) {
        const hasClone = clones.has(value);
        if (hasClone) clone = clones.get(value);else {
          clone = isList ? [] : {};
          clones.set(value, clone);
        }

        if (!recursed.has(value)) {
          const pathPrefix = path ? `${path}.` : '';
          const recursedDeeper = new Set(recursed).add(value);

          if (isList) {
            let index = 0;

            for (const item of value) {
              const itemClone = recurse(item, pathPrefix + index++, recursedDeeper);
              if (!hasClone) clone.push(itemClone);
            }
          } else for (const key in value) {
            const propertyClone = recurse(value[key], pathPrefix + key, recursedDeeper);
            if (!hasClone) clone[key] = propertyClone;
          }
        }
      }
    }

    return clone;
  }

  return {
    clone: recurse(value, path, new Set()),
    files
  };
};

var canUseDOM = (function () {
  return typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
});

const isExtractableFileEnhanced = (value) => isExtractableFile(value) || value !== null && typeof value === "object" && typeof value.pipe === "function" || value !== null && typeof value === "object" && typeof value.stream === "function";

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var Middleware = /*#__PURE__*/function () {
  function Middleware(fns) {
    var _this = this;

    if (fns.length === 0) {
      fns.push(function (_, next) {
        return next();
      });
    }

    var _loop = function _loop() {
      var fn = _step.value;

      if (typeof fn !== "function") {
        throw new Error("GraphQLClient Middleware: middleware has to be of type `function`");
      }

      _this.run = function (stack) {
        return function (opts, next) {
          stack(opts, function () {
            fn.apply(_this, [opts, next.bind.apply(next, [null, opts])]);
          });
        };
      }(_this.run);
    };

    for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;) {
      _loop();
    }
  }

  var _proto = Middleware.prototype;

  _proto.run = function run(opts, next) {
    next.apply(this, opts);
  };

  return Middleware;
}();

const pipeP = (fns) => (arg) => fns.reduce((p, f) => p.then(f), Promise.resolve(arg));

var __defProp$4 = Object.defineProperty;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
class GraphQLClient {
  constructor(config) {
    if (!config) {
      throw new Error(`GraphQLClient: config is required as first parameter`);
    }
    this.fullWsTransport = config.fullWsTransport;
    if (typeof config.subscriptionClient === "function") {
      this.subscriptionClient = config.subscriptionClient();
    } else {
      this.subscriptionClient = config.subscriptionClient;
    }
    this.verifyConfig(config);
    this.cache = config.cache;
    this.headers = config.headers || {};
    this.ssrMode = config.ssrMode;
    this.ssrPromises = [];
    this.url = config.url;
    this.fetch = config.fetch || (typeof fetch !== "undefined" && fetch ? fetch.bind(void 0) : void 0);
    this.fetchOptions = config.fetchOptions || {};
    this.FormData = config.FormData || (typeof FormData !== "undefined" ? FormData : void 0);
    this.logErrors = config.logErrors !== void 0 ? config.logErrors : true;
    this.onError = config.onError;
    this.useGETForQueries = config.useGETForQueries === true;
    this.middleware = new Middleware(config.middleware || []);
    this.mutationsEmitter = new EventEmitter__default['default']();
  }
  verifyConfig(config) {
    if (!config.url) {
      if (this.fullWsTransport) {
        if (!this.subscriptionClient) {
          throw new Error("GraphQLClient: subscriptionClient is required");
        }
      } else {
        throw new Error("GraphQLClient: config.url is required");
      }
    }
    if (config.fetch && typeof config.fetch !== "function") {
      throw new Error("GraphQLClient: config.fetch must be a function");
    }
    if ((canUseDOM() || config.ssrMode) && !config.fetch && typeof fetch !== "function") {
      throw new Error("GraphQLClient: fetch must be polyfilled or passed in new GraphQLClient({ fetch })");
    }
    if (config.ssrMode && !config.cache) {
      throw new Error("GraphQLClient: config.cache is required when in ssrMode");
    }
  }
  setHeader(key, value) {
    this.headers[key] = value;
    return this;
  }
  setHeaders(headers) {
    this.headers = headers;
    return this;
  }
  removeHeader(key) {
    delete this.headers[key];
    return this;
  }
  logErrorResult({ result, operation }) {
    console.error("GraphQL Hooks Error");
    console.groupCollapsed("---> Full Error Details");
    console.groupCollapsed("Operation:");
    console.log(operation);
    console.groupEnd();
    const error = result.error;
    if (error) {
      if (error.fetchError) {
        console.groupCollapsed("FETCH ERROR:");
        console.log(error.fetchError);
        console.groupEnd();
      }
      if (error.httpError) {
        console.groupCollapsed("HTTP ERROR:");
        console.log(error.httpError);
        console.groupEnd();
      }
      if (error.graphQLErrors && error.graphQLErrors.length > 0) {
        console.groupCollapsed("GRAPHQL ERROR:");
        error.graphQLErrors.forEach((err) => console.log(err));
        console.groupEnd();
      }
    }
    console.groupEnd();
  }
  generateResult({
    fetchError,
    httpError,
    graphQLErrors,
    data
  }) {
    const errorFound = !!(graphQLErrors && graphQLErrors.length > 0 || fetchError || httpError);
    return !errorFound ? { data } : { data, error: { fetchError, httpError, graphQLErrors } };
  }
  getCacheKey(operation, options = {}) {
    const fetchOptions = __spreadValues$4(__spreadValues$4({}, this.fetchOptions), options.fetchOptionsOverrides);
    return {
      operation,
      fetchOptions
    };
  }
  getCache(cacheKey) {
    const cacheHit = this.cache ? this.cache.get(cacheKey) : null;
    if (cacheHit) {
      return cacheHit;
    }
  }
  saveCache(cacheKey, value) {
    if (this.cache) {
      this.cache.set(cacheKey, value);
    }
  }
  getFetchOptions(operation, fetchOptionsOverrides = {}) {
    const fetchOptions = __spreadValues$4(__spreadValues$4({
      method: "POST",
      headers: __spreadValues$4({}, this.headers)
    }, this.fetchOptions), fetchOptionsOverrides);
    if (fetchOptions.method === "GET") {
      return fetchOptions;
    }
    const { clone, files } = extractFiles(operation, "", isExtractableFileEnhanced);
    const operationJSON = JSON.stringify(clone);
    if (files.size) {
      if (!this.FormData) {
        throw new Error("GraphQLClient: FormData must be polyfilled or passed in new GraphQLClient({ FormData })");
      }
      const form = new this.FormData();
      form.append("operations", operationJSON);
      const map = {};
      let i = 0;
      files.forEach((paths) => {
        map[++i] = paths;
      });
      form.append("map", JSON.stringify(map));
      i = 0;
      files.forEach((paths, file) => {
        form.append(`${++i}`, file, file.name);
      });
      fetchOptions.body = form;
    } else {
      fetchOptions.headers["Content-Type"] = "application/json";
      fetchOptions.body = operationJSON;
    }
    return fetchOptions;
  }
  request(operation, options) {
    const responseHandlers = [];
    const addResponseHook = (handler) => responseHandlers.push(handler);
    return new Promise((resolve, reject) => this.middleware.run({ operation, client: this, addResponseHook, resolve, reject }, ({ operation: updatedOperation }) => {
      const transformResponse = (res) => {
        if (responseHandlers.length > 0) {
          return pipeP(responseHandlers)(res);
        }
        return res;
      };
      if (this.fullWsTransport) {
        return this.requestViaWS(updatedOperation).then(transformResponse).then(resolve).catch(reject);
      }
      if (this.url) {
        return this.requestViaHttp(updatedOperation, options).then(transformResponse).then(resolve).catch(reject);
      }
      reject(new Error("GraphQLClient: config.url is required"));
    }));
  }
  requestViaHttp(operation, options = {}) {
    let url = this.url;
    const fetchOptions = this.getFetchOptions(operation, options.fetchOptionsOverrides);
    if (fetchOptions.method === "GET") {
      const paramsQueryString = Object.entries(operation).filter(([, v]) => !!v).map(([k, v]) => {
        if (k === "variables" || k === "extensions") {
          v = JSON.stringify(v);
        }
        return `${k}=${encodeURIComponent(v)}`;
      }).join("&");
      url = url + "?" + paramsQueryString;
    }
    return this.fetch(url, fetchOptions).then((response) => {
      if (!response.ok) {
        return response.text().then((body) => {
          const { status, statusText } = response;
          return this.generateResult({
            httpError: {
              status,
              statusText,
              body
            }
          });
        });
      } else {
        return response.json().then(({ errors, data }) => {
          return this.generateResult({
            graphQLErrors: errors,
            data: typeof options.responseReducer === "function" && options.responseReducer(data, response) || data
          });
        });
      }
    }).catch((error) => {
      return this.generateResult({
        fetchError: error
      });
    }).then((result) => {
      if (result.error) {
        if (this.logErrors) {
          this.logErrorResult({ result, operation });
        }
        if (this.onError) {
          this.onError({ result, operation });
        }
      }
      return result;
    });
  }
  requestViaWS(operationPayload) {
    return new Promise((resolve, reject) => {
      let data;
      try {
        const observable = this.createSubscription(operationPayload);
        const subscription = observable.subscribe({
          next: (result) => {
            data = result;
          },
          error: reject,
          complete: () => {
            subscription.unsubscribe();
            resolve(data);
          }
        });
      } catch (e) {
        reject(e);
      }
    });
  }
  createSubscription(operationPayload) {
    if (!this.subscriptionClient) {
      throw new Error("No SubscriptionClient! Please set in the constructor.");
    }
    if (isGraphQLWsClient(this.subscriptionClient)) {
      return {
        subscribe: (sink) => ({
          unsubscribe: this.subscriptionClient.subscribe(operationPayload, sink)
        })
      };
    } else {
      return this.subscriptionClient.request(operationPayload);
    }
  }
}
function isGraphQLWsClient(value) {
  return typeof value.subscribe === "function";
}

class LocalGraphQLError {
  constructor(error) {
    this.fetchError = error.fetchError;
    this.httpError = error.httpError;
    this.graphQLErrors = error.graphQLErrors;
  }
}

var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
class LocalGraphQLClient extends GraphQLClient {
  constructor(config) {
    super(__spreadValues$3({ url: "" }, config));
    this.localQueries = config.localQueries;
    this.requestDelayMs = config.requestDelayMs || 0;
    if (!this.localQueries) {
      throw new Error("LocalGraphQLClient: `localQueries` object required in the constructor options");
    }
  }
  verifyConfig() {
  }
  request(operation) {
    if (!this.localQueries[operation.query]) {
      throw new Error(`LocalGraphQLClient: no query match for: ${operation.query}`);
    }
    return timeoutPromise(this.requestDelayMs).then(() => Promise.resolve(this.localQueries[operation.query](operation.variables, operation.operationName))).then((result) => {
      if (result instanceof LocalGraphQLError) {
        return { error: result };
      }
      return { data: result };
    });
  }
}
function timeoutPromise(delayInMs) {
  return new Promise((resolve) => {
    setTimeout(resolve, delayInMs);
  });
}

var has = Object.prototype.hasOwnProperty;

function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar)) return key;
  }
}

function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar) return true;

  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date) return foo.getTime() === bar.getTime();
    if (ctor === RegExp) return foo.toString() === bar.toString();

    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]));
      }

      return len === -1;
    }

    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }

      for (len of foo) {
        tmp = len;

        if (tmp && typeof tmp === 'object') {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }

        if (!bar.has(tmp)) return false;
      }

      return true;
    }

    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }

      for (len of foo) {
        tmp = len[0];

        if (tmp && typeof tmp === 'object') {
          tmp = find(bar, tmp);
          if (!tmp) return false;
        }

        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }

      return true;
    }

    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len));
      }

      return len === -1;
    }

    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len]);
      }

      return len === -1;
    }

    if (!ctor || typeof foo === 'object') {
      len = 0;

      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor)) return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
      }

      return Object.keys(bar).length === len;
    }
  }

  return foo !== foo && bar !== bar;
}

var __defProp$2 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
const actionTypes = {
  RESET_STATE: "RESET_STATE",
  LOADING: "LOADING",
  CACHE_HIT: "CACHE_HIT",
  REQUEST_RESULT: "REQUEST_RESULT"
};
function reducer(state, action) {
  switch (action.type) {
    case actionTypes.RESET_STATE:
      return action.initialState;
    case actionTypes.LOADING:
      if (state.error) {
        return __spreadProps$1(__spreadValues$2({}, action.initialState), {
          data: state.data,
          loading: true
        });
      }
      if (state.loading) {
        return state;
      }
      return __spreadProps$1(__spreadValues$2({}, state), {
        loading: true
      });
    case actionTypes.CACHE_HIT:
      if (state.cacheHit && !action.resetState) {
        return state;
      }
      return __spreadProps$1(__spreadValues$2({}, action.result), {
        cacheHit: true,
        loading: false
      });
    case actionTypes.REQUEST_RESULT:
      return __spreadProps$1(__spreadValues$2({}, action.result), {
        data: state.data && action.result.data && action.updateData ? action.updateData(state.data, action.result.data) : action.result.data,
        cacheHit: false,
        loading: false
      });
    default:
      return state;
  }
}
function useDeepCompareCallback(callback, deps) {
  const ref = React__default['default'].useRef();
  if (!dequal(deps, ref.current)) {
    ref.current = deps;
  }
  return React__default['default'].useCallback(callback, ref.current);
}
function useClientRequest(query, initialOpts = {}) {
  if (typeof query !== "string") {
    throw new Error("Your query must be a string. If you are using the `gql` template literal from graphql-tag, remove it from your query.");
  }
  const contextClient = React__default['default'].useContext(ClientContext);
  const client = initialOpts.client || contextClient;
  if (client === null || client === void 0) {
    throw new Error("A client must be provided in order to use the useClientRequest hook.");
  }
  const isMounted = React__default['default'].useRef(true);
  const activeCacheKey = React__default['default'].useRef(null);
  const operation = {
    query,
    variables: initialOpts.variables,
    operationName: initialOpts.operationName,
    persisted: initialOpts.persisted
  };
  if (initialOpts.persisted || client.useGETForQueries && !initialOpts.isMutation) {
    initialOpts.fetchOptionsOverrides = __spreadProps$1(__spreadValues$2({}, initialOpts.fetchOptionsOverrides), {
      method: "GET"
    });
  }
  const cacheKey = client.getCacheKey(operation, initialOpts);
  const isDeferred = initialOpts.isMutation || initialOpts.isManual || initialOpts.skip;
  const initialCacheHit = initialOpts.skipCache || !client.cache || !cacheKey ? null : client.cache.get(cacheKey);
  const initialState = __spreadProps$1(__spreadValues$2({}, initialCacheHit), {
    cacheHit: !!initialCacheHit,
    loading: isDeferred ? false : !initialCacheHit
  });
  const [state, dispatch] = React__default['default'].useReducer(reducer, initialState);
  const stringifiedCacheKey = JSON.stringify(cacheKey);
  React__default['default'].useEffect(() => {
    if (!initialOpts.updateData) {
      dispatch({ type: actionTypes.RESET_STATE, initialState });
    }
  }, [stringifiedCacheKey]);
  React__default['default'].useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  const fetchData = useDeepCompareCallback((newOpts) => {
    const revisedOpts = __spreadValues$2(__spreadValues$2({}, initialOpts), newOpts);
    const revisedOperation = __spreadProps$1(__spreadValues$2({}, operation), {
      variables: revisedOpts.variables,
      operationName: revisedOpts.operationName
    });
    if (!isMounted.current) {
      return Promise.resolve({
        error: {
          fetchError: new Error("fetchData should not be called after hook unmounted")
        },
        loading: false,
        cacheHit: false
      });
    }
    const revisedCacheKey = client.getCacheKey(revisedOperation, revisedOpts);
    activeCacheKey.current = revisedCacheKey;
    const cacheHit = revisedOpts.skipCache ? null : client.getCache(revisedCacheKey);
    if (cacheHit) {
      dispatch({
        type: actionTypes.CACHE_HIT,
        result: cacheHit,
        resetState: stringifiedCacheKey !== JSON.stringify(state.cacheKey)
      });
      return Promise.resolve(cacheHit);
    }
    dispatch({ type: actionTypes.LOADING, initialState });
    return client.request(revisedOperation, revisedOpts).then((result) => {
      if (revisedOpts.updateData && typeof revisedOpts.updateData !== "function") {
        throw new Error("options.updateData must be a function");
      }
      const actionResult = __spreadValues$2({}, result);
      if (revisedOpts.useCache) {
        actionResult.useCache = true;
        actionResult.cacheKey = revisedCacheKey;
        if (client.ssrMode) {
          const cacheValue = {
            error: actionResult.error,
            data: revisedOpts.updateData ? revisedOpts.updateData(state.data, actionResult.data) : actionResult.data
          };
          client.saveCache(revisedCacheKey, cacheValue);
        }
      }
      if (isMounted.current && revisedCacheKey === activeCacheKey.current) {
        dispatch({
          type: actionTypes.REQUEST_RESULT,
          updateData: revisedOpts.updateData,
          result: actionResult
        });
      }
      if (initialOpts.isMutation) {
        client.mutationsEmitter.emit(query, __spreadProps$1(__spreadValues$2({}, revisedOperation), {
          mutation: query,
          result: actionResult
        }));
      }
      return result;
    });
  }, [client, initialOpts, operation]);
  React__default['default'].useEffect(() => {
    if (state.useCache && !client.ssrMode) {
      client.saveCache(state.cacheKey, state);
    }
  }, [client, state]);
  const reset = (desiredState = {}) => dispatch({
    type: actionTypes.RESET_STATE,
    initialState: __spreadValues$2(__spreadValues$2({}, initialState), desiredState)
  });
  return [fetchData, state, reset];
}

function createRefetchMutationsMap(refetchAfterMutations) {
  var mutations = Array.isArray(refetchAfterMutations) ? refetchAfterMutations : [refetchAfterMutations];
  var result = {};
  mutations.forEach(function (mutationInfo) {
    if (mutationInfo == null) return;
    var paramType = typeof mutationInfo;

    if (paramType === "string") {
      result[mutationInfo] = {};
    } else if (paramType === "object") {
      var filter = mutationInfo.filter,
          mutation = mutationInfo.mutation;
      result[mutation] = {
        filter: filter
      };
    }
  });
  return result;
}

var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const defaultOpts = {
  useCache: true,
  skip: false,
  throwErrors: false
};
function useQuery(query, opts = {}) {
  const allOpts = __spreadValues$1(__spreadValues$1({}, defaultOpts), opts);
  const contextClient = React__default['default'].useContext(ClientContext);
  const client = opts.client || contextClient;
  const [calledDuringSSR, setCalledDuringSSR] = React__default['default'].useState(false);
  const [queryReq, state] = useClientRequest(query, allOpts);
  if (!client) {
    throw new Error("useQuery() requires a client to be passed in the options or as a context value");
  }
  if (client.ssrMode && opts.ssr !== false && !calledDuringSSR && !opts.skipCache && !opts.skip) {
    if (!state.data && !state.error) {
      const p = queryReq();
      client.ssrPromises.push(p);
    }
    setCalledDuringSSR(true);
  }
  const stringifiedAllOpts = JSON.stringify(allOpts);
  React__default['default'].useEffect(() => {
    if (allOpts.skip) {
      return;
    }
    queryReq();
  }, [query, stringifiedAllOpts]);
  React__default['default'].useEffect(() => {
    if (state.error && allOpts.throwErrors) {
      throw state.error;
    }
  }, [state.error, allOpts.throwErrors]);
  const refetch = React__default['default'].useCallback((options = {}) => queryReq(__spreadValues$1({
    skipCache: true,
    updateData: (_, data) => data
  }, options)), [queryReq]);
  React__default['default'].useEffect(function subscribeToMutationsAndRefetch() {
    const mutationsMap = createRefetchMutationsMap(opts.refetchAfterMutations);
    const mutations = Object.keys(mutationsMap);
    const conditionalRefetch = ({ mutation, variables }) => {
      const { filter } = mutationsMap[mutation];
      if (!filter || variables && filter(variables)) {
        refetch();
      }
    };
    mutations.forEach((mutation) => {
      client.mutationsEmitter.on(mutation, conditionalRefetch);
    });
    return () => {
      mutations.forEach((mutation) => {
        client.mutationsEmitter.removeListener(mutation, conditionalRefetch);
      });
    };
  }, [opts.refetchAfterMutations, refetch, client.mutationsEmitter]);
  return __spreadProps(__spreadValues$1({}, state), {
    refetch
  });
}

function useSubscription(options, callback) {
  const callbackRef = React.useRef(callback);
  callbackRef.current = callback;
  const contextClient = React.useContext(ClientContext);
  const client = options.client || contextClient;
  if (!client) {
    throw new Error("useSubscription() requires a client to be passed in the options or as a context value");
  }
  const request = {
    query: options.query,
    variables: options.variables
  };
  React.useEffect(() => {
    const observable = client.createSubscription(request);
    const subscription = observable.subscribe({
      next: (result) => {
        callbackRef.current(result);
      },
      error: (errors) => {
        callbackRef.current({ errors });
      },
      complete: () => {
        subscription.unsubscribe();
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }, []);
}

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const useManualQuery = (query, options = {}) => useClientRequest(query, __spreadValues({ useCache: true, isManual: true }, options));
const useMutation = (query, options = {}) => useClientRequest(query, __spreadValues({ isMutation: true }, options));

exports.ClientContext = ClientContext;
exports.GraphQLClient = GraphQLClient;
exports.LocalGraphQLClient = LocalGraphQLClient;
exports.LocalGraphQLError = LocalGraphQLError;
exports.useClientRequest = useClientRequest;
exports.useManualQuery = useManualQuery;
exports.useMutation = useMutation;
exports.useQuery = useQuery;
exports.useSubscription = useSubscription;

Object.defineProperty(exports, '__esModule', { value: true });

})));
