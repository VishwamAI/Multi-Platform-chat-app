/// <reference types="node" />
import EventEmitter from 'events';
import { Client as GraphQLWsClient } from 'graphql-ws';
import { SubscriptionClient } from 'subscriptions-transport-ws';
import Middleware from './Middleware';
import type { UseClientRequestOptions, Cache, ClientOptions, FetchFunction, GenerateResultOptions, OnErrorFunction, Operation, RequestOptions, Result } from './types/common-types';
declare class GraphQLClient {
    url: string;
    ssrPromises: Promise<any>[];
    FormData?: any;
    fetch?: FetchFunction;
    fetchOptions: RequestInit;
    logErrors: boolean;
    useGETForQueries: boolean;
    middleware: Middleware;
    mutationsEmitter: EventEmitter;
    cache?: Cache;
    headers: Headers | {
        [key: string]: string;
    };
    ssrMode?: boolean;
    subscriptionClient?: SubscriptionClient | GraphQLWsClient;
    fullWsTransport?: boolean;
    onError?: OnErrorFunction;
    constructor(config: ClientOptions);
    /** Checks that the given config has the correct required options */
    verifyConfig(config: any): void;
    setHeader(key: any, value: any): this;
    setHeaders(headers: any): this;
    removeHeader(key: any): this;
    logErrorResult({ result, operation }: {
        result: any;
        operation: any;
    }): void;
    generateResult<ResponseData = any, TGraphQLError = any>({ fetchError, httpError, graphQLErrors, data }: GenerateResultOptions<ResponseData, TGraphQLError>): Result<ResponseData, TGraphQLError>;
    getCacheKey<Variables = object>(operation: Operation, options?: UseClientRequestOptions<any, Variables>): {
        operation: Operation<object>;
        fetchOptions: {
            body?: BodyInit | null | undefined;
            cache?: RequestCache | undefined;
            credentials?: RequestCredentials | undefined;
            headers?: HeadersInit | undefined;
            integrity?: string | undefined;
            keepalive?: boolean | undefined;
            method?: string | undefined;
            mode?: RequestMode | undefined;
            redirect?: RequestRedirect | undefined;
            referrer?: string | undefined;
            referrerPolicy?: ReferrerPolicy | undefined;
            signal?: AbortSignal | null | undefined;
            window?: null | undefined;
        };
    };
    getCache(cacheKey: any): object | undefined;
    saveCache(cacheKey: any, value: any): void;
    getFetchOptions(operation: any, fetchOptionsOverrides?: {}): {
        body?: BodyInit | null | undefined;
        cache?: RequestCache | undefined;
        credentials?: RequestCredentials | undefined;
        headers: HeadersInit;
        integrity?: string | undefined;
        keepalive?: boolean | undefined;
        method: string;
        mode?: RequestMode | undefined;
        redirect?: RequestRedirect | undefined;
        referrer?: string | undefined;
        referrerPolicy?: ReferrerPolicy | undefined;
        signal?: AbortSignal | null | undefined;
        window?: null | undefined;
    };
    request<ResponseData, TGraphQLError = object, TVariables = object>(operation: Operation<TVariables>, options?: RequestOptions): Promise<Result<ResponseData, TGraphQLError>>;
    requestViaHttp<ResponseData, TGraphQLError = object, TVariables = object>(operation: Operation<TVariables>, options?: RequestOptions): Promise<Result<ResponseData, TGraphQLError>>;
    requestViaWS(operationPayload: any): Promise<unknown>;
    createSubscription(operationPayload: any): import("subscriptions-transport-ws").Observable<import("graphql").ExecutionResult<import("graphql/jsutils/ObjMap").ObjMap<unknown>, import("graphql/jsutils/ObjMap").ObjMap<unknown>>>;
}
export default GraphQLClient;
