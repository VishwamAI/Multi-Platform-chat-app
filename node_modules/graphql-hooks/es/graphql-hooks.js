import React, { useRef, useContext, useEffect } from 'react';
import EventEmitter from 'events';
import { isExtractableFile, extractFiles } from 'extract-files';
import { dequal } from 'dequal';

const ClientContext = React.createContext(null);
ClientContext.displayName = "ClientContext";

var canUseDOM = (function () {
  return typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
});

const isExtractableFileEnhanced = (value) => isExtractableFile(value) || value !== null && typeof value === "object" && typeof value.pipe === "function" || value !== null && typeof value === "object" && typeof value.stream === "function";

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var Middleware = /*#__PURE__*/function () {
  function Middleware(fns) {
    var _this = this;

    if (fns.length === 0) {
      fns.push(function (_, next) {
        return next();
      });
    }

    var _loop = function _loop() {
      var fn = _step.value;

      if (typeof fn !== "function") {
        throw new Error("GraphQLClient Middleware: middleware has to be of type `function`");
      }

      _this.run = function (stack) {
        return function (opts, next) {
          stack(opts, function () {
            fn.apply(_this, [opts, next.bind.apply(next, [null, opts])]);
          });
        };
      }(_this.run);
    };

    for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;) {
      _loop();
    }
  }

  var _proto = Middleware.prototype;

  _proto.run = function run(opts, next) {
    next.apply(this, opts);
  };

  return Middleware;
}();

const pipeP = (fns) => (arg) => fns.reduce((p, f) => p.then(f), Promise.resolve(arg));

var __defProp$4 = Object.defineProperty;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
class GraphQLClient {
  constructor(config) {
    if (!config) {
      throw new Error(`GraphQLClient: config is required as first parameter`);
    }
    this.fullWsTransport = config.fullWsTransport;
    if (typeof config.subscriptionClient === "function") {
      this.subscriptionClient = config.subscriptionClient();
    } else {
      this.subscriptionClient = config.subscriptionClient;
    }
    this.verifyConfig(config);
    this.cache = config.cache;
    this.headers = config.headers || {};
    this.ssrMode = config.ssrMode;
    this.ssrPromises = [];
    this.url = config.url;
    this.fetch = config.fetch || (typeof fetch !== "undefined" && fetch ? fetch.bind(void 0) : void 0);
    this.fetchOptions = config.fetchOptions || {};
    this.FormData = config.FormData || (typeof FormData !== "undefined" ? FormData : void 0);
    this.logErrors = config.logErrors !== void 0 ? config.logErrors : true;
    this.onError = config.onError;
    this.useGETForQueries = config.useGETForQueries === true;
    this.middleware = new Middleware(config.middleware || []);
    this.mutationsEmitter = new EventEmitter();
  }
  verifyConfig(config) {
    if (!config.url) {
      if (this.fullWsTransport) {
        if (!this.subscriptionClient) {
          throw new Error("GraphQLClient: subscriptionClient is required");
        }
      } else {
        throw new Error("GraphQLClient: config.url is required");
      }
    }
    if (config.fetch && typeof config.fetch !== "function") {
      throw new Error("GraphQLClient: config.fetch must be a function");
    }
    if ((canUseDOM() || config.ssrMode) && !config.fetch && typeof fetch !== "function") {
      throw new Error("GraphQLClient: fetch must be polyfilled or passed in new GraphQLClient({ fetch })");
    }
    if (config.ssrMode && !config.cache) {
      throw new Error("GraphQLClient: config.cache is required when in ssrMode");
    }
  }
  setHeader(key, value) {
    this.headers[key] = value;
    return this;
  }
  setHeaders(headers) {
    this.headers = headers;
    return this;
  }
  removeHeader(key) {
    delete this.headers[key];
    return this;
  }
  logErrorResult({ result, operation }) {
    console.error("GraphQL Hooks Error");
    console.groupCollapsed("---> Full Error Details");
    console.groupCollapsed("Operation:");
    console.log(operation);
    console.groupEnd();
    const error = result.error;
    if (error) {
      if (error.fetchError) {
        console.groupCollapsed("FETCH ERROR:");
        console.log(error.fetchError);
        console.groupEnd();
      }
      if (error.httpError) {
        console.groupCollapsed("HTTP ERROR:");
        console.log(error.httpError);
        console.groupEnd();
      }
      if (error.graphQLErrors && error.graphQLErrors.length > 0) {
        console.groupCollapsed("GRAPHQL ERROR:");
        error.graphQLErrors.forEach((err) => console.log(err));
        console.groupEnd();
      }
    }
    console.groupEnd();
  }
  generateResult({
    fetchError,
    httpError,
    graphQLErrors,
    data
  }) {
    const errorFound = !!(graphQLErrors && graphQLErrors.length > 0 || fetchError || httpError);
    return !errorFound ? { data } : { data, error: { fetchError, httpError, graphQLErrors } };
  }
  getCacheKey(operation, options = {}) {
    const fetchOptions = __spreadValues$4(__spreadValues$4({}, this.fetchOptions), options.fetchOptionsOverrides);
    return {
      operation,
      fetchOptions
    };
  }
  getCache(cacheKey) {
    const cacheHit = this.cache ? this.cache.get(cacheKey) : null;
    if (cacheHit) {
      return cacheHit;
    }
  }
  saveCache(cacheKey, value) {
    if (this.cache) {
      this.cache.set(cacheKey, value);
    }
  }
  getFetchOptions(operation, fetchOptionsOverrides = {}) {
    const fetchOptions = __spreadValues$4(__spreadValues$4({
      method: "POST",
      headers: __spreadValues$4({}, this.headers)
    }, this.fetchOptions), fetchOptionsOverrides);
    if (fetchOptions.method === "GET") {
      return fetchOptions;
    }
    const { clone, files } = extractFiles(operation, "", isExtractableFileEnhanced);
    const operationJSON = JSON.stringify(clone);
    if (files.size) {
      if (!this.FormData) {
        throw new Error("GraphQLClient: FormData must be polyfilled or passed in new GraphQLClient({ FormData })");
      }
      const form = new this.FormData();
      form.append("operations", operationJSON);
      const map = {};
      let i = 0;
      files.forEach((paths) => {
        map[++i] = paths;
      });
      form.append("map", JSON.stringify(map));
      i = 0;
      files.forEach((paths, file) => {
        form.append(`${++i}`, file, file.name);
      });
      fetchOptions.body = form;
    } else {
      fetchOptions.headers["Content-Type"] = "application/json";
      fetchOptions.body = operationJSON;
    }
    return fetchOptions;
  }
  request(operation, options) {
    const responseHandlers = [];
    const addResponseHook = (handler) => responseHandlers.push(handler);
    return new Promise((resolve, reject) => this.middleware.run({ operation, client: this, addResponseHook, resolve, reject }, ({ operation: updatedOperation }) => {
      const transformResponse = (res) => {
        if (responseHandlers.length > 0) {
          return pipeP(responseHandlers)(res);
        }
        return res;
      };
      if (this.fullWsTransport) {
        return this.requestViaWS(updatedOperation).then(transformResponse).then(resolve).catch(reject);
      }
      if (this.url) {
        return this.requestViaHttp(updatedOperation, options).then(transformResponse).then(resolve).catch(reject);
      }
      reject(new Error("GraphQLClient: config.url is required"));
    }));
  }
  requestViaHttp(operation, options = {}) {
    let url = this.url;
    const fetchOptions = this.getFetchOptions(operation, options.fetchOptionsOverrides);
    if (fetchOptions.method === "GET") {
      const paramsQueryString = Object.entries(operation).filter(([, v]) => !!v).map(([k, v]) => {
        if (k === "variables" || k === "extensions") {
          v = JSON.stringify(v);
        }
        return `${k}=${encodeURIComponent(v)}`;
      }).join("&");
      url = url + "?" + paramsQueryString;
    }
    return this.fetch(url, fetchOptions).then((response) => {
      if (!response.ok) {
        return response.text().then((body) => {
          const { status, statusText } = response;
          return this.generateResult({
            httpError: {
              status,
              statusText,
              body
            }
          });
        });
      } else {
        return response.json().then(({ errors, data }) => {
          return this.generateResult({
            graphQLErrors: errors,
            data: typeof options.responseReducer === "function" && options.responseReducer(data, response) || data
          });
        });
      }
    }).catch((error) => {
      return this.generateResult({
        fetchError: error
      });
    }).then((result) => {
      if (result.error) {
        if (this.logErrors) {
          this.logErrorResult({ result, operation });
        }
        if (this.onError) {
          this.onError({ result, operation });
        }
      }
      return result;
    });
  }
  requestViaWS(operationPayload) {
    return new Promise((resolve, reject) => {
      let data;
      try {
        const observable = this.createSubscription(operationPayload);
        const subscription = observable.subscribe({
          next: (result) => {
            data = result;
          },
          error: reject,
          complete: () => {
            subscription.unsubscribe();
            resolve(data);
          }
        });
      } catch (e) {
        reject(e);
      }
    });
  }
  createSubscription(operationPayload) {
    if (!this.subscriptionClient) {
      throw new Error("No SubscriptionClient! Please set in the constructor.");
    }
    if (isGraphQLWsClient(this.subscriptionClient)) {
      return {
        subscribe: (sink) => ({
          unsubscribe: this.subscriptionClient.subscribe(operationPayload, sink)
        })
      };
    } else {
      return this.subscriptionClient.request(operationPayload);
    }
  }
}
function isGraphQLWsClient(value) {
  return typeof value.subscribe === "function";
}

class LocalGraphQLError {
  constructor(error) {
    this.fetchError = error.fetchError;
    this.httpError = error.httpError;
    this.graphQLErrors = error.graphQLErrors;
  }
}

var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
class LocalGraphQLClient extends GraphQLClient {
  constructor(config) {
    super(__spreadValues$3({ url: "" }, config));
    this.localQueries = config.localQueries;
    this.requestDelayMs = config.requestDelayMs || 0;
    if (!this.localQueries) {
      throw new Error("LocalGraphQLClient: `localQueries` object required in the constructor options");
    }
  }
  verifyConfig() {
  }
  request(operation) {
    if (!this.localQueries[operation.query]) {
      throw new Error(`LocalGraphQLClient: no query match for: ${operation.query}`);
    }
    return timeoutPromise(this.requestDelayMs).then(() => Promise.resolve(this.localQueries[operation.query](operation.variables, operation.operationName))).then((result) => {
      if (result instanceof LocalGraphQLError) {
        return { error: result };
      }
      return { data: result };
    });
  }
}
function timeoutPromise(delayInMs) {
  return new Promise((resolve) => {
    setTimeout(resolve, delayInMs);
  });
}

var __defProp$2 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
const actionTypes = {
  RESET_STATE: "RESET_STATE",
  LOADING: "LOADING",
  CACHE_HIT: "CACHE_HIT",
  REQUEST_RESULT: "REQUEST_RESULT"
};
function reducer(state, action) {
  switch (action.type) {
    case actionTypes.RESET_STATE:
      return action.initialState;
    case actionTypes.LOADING:
      if (state.error) {
        return __spreadProps$1(__spreadValues$2({}, action.initialState), {
          data: state.data,
          loading: true
        });
      }
      if (state.loading) {
        return state;
      }
      return __spreadProps$1(__spreadValues$2({}, state), {
        loading: true
      });
    case actionTypes.CACHE_HIT:
      if (state.cacheHit && !action.resetState) {
        return state;
      }
      return __spreadProps$1(__spreadValues$2({}, action.result), {
        cacheHit: true,
        loading: false
      });
    case actionTypes.REQUEST_RESULT:
      return __spreadProps$1(__spreadValues$2({}, action.result), {
        data: state.data && action.result.data && action.updateData ? action.updateData(state.data, action.result.data) : action.result.data,
        cacheHit: false,
        loading: false
      });
    default:
      return state;
  }
}
function useDeepCompareCallback(callback, deps) {
  const ref = React.useRef();
  if (!dequal(deps, ref.current)) {
    ref.current = deps;
  }
  return React.useCallback(callback, ref.current);
}
function useClientRequest(query, initialOpts = {}) {
  if (typeof query !== "string") {
    throw new Error("Your query must be a string. If you are using the `gql` template literal from graphql-tag, remove it from your query.");
  }
  const contextClient = React.useContext(ClientContext);
  const client = initialOpts.client || contextClient;
  if (client === null || client === void 0) {
    throw new Error("A client must be provided in order to use the useClientRequest hook.");
  }
  const isMounted = React.useRef(true);
  const activeCacheKey = React.useRef(null);
  const operation = {
    query,
    variables: initialOpts.variables,
    operationName: initialOpts.operationName,
    persisted: initialOpts.persisted
  };
  if (initialOpts.persisted || client.useGETForQueries && !initialOpts.isMutation) {
    initialOpts.fetchOptionsOverrides = __spreadProps$1(__spreadValues$2({}, initialOpts.fetchOptionsOverrides), {
      method: "GET"
    });
  }
  const cacheKey = client.getCacheKey(operation, initialOpts);
  const isDeferred = initialOpts.isMutation || initialOpts.isManual || initialOpts.skip;
  const initialCacheHit = initialOpts.skipCache || !client.cache || !cacheKey ? null : client.cache.get(cacheKey);
  const initialState = __spreadProps$1(__spreadValues$2({}, initialCacheHit), {
    cacheHit: !!initialCacheHit,
    loading: isDeferred ? false : !initialCacheHit
  });
  const [state, dispatch] = React.useReducer(reducer, initialState);
  const stringifiedCacheKey = JSON.stringify(cacheKey);
  React.useEffect(() => {
    if (!initialOpts.updateData) {
      dispatch({ type: actionTypes.RESET_STATE, initialState });
    }
  }, [stringifiedCacheKey]);
  React.useEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  const fetchData = useDeepCompareCallback((newOpts) => {
    const revisedOpts = __spreadValues$2(__spreadValues$2({}, initialOpts), newOpts);
    const revisedOperation = __spreadProps$1(__spreadValues$2({}, operation), {
      variables: revisedOpts.variables,
      operationName: revisedOpts.operationName
    });
    if (!isMounted.current) {
      return Promise.resolve({
        error: {
          fetchError: new Error("fetchData should not be called after hook unmounted")
        },
        loading: false,
        cacheHit: false
      });
    }
    const revisedCacheKey = client.getCacheKey(revisedOperation, revisedOpts);
    activeCacheKey.current = revisedCacheKey;
    const cacheHit = revisedOpts.skipCache ? null : client.getCache(revisedCacheKey);
    if (cacheHit) {
      dispatch({
        type: actionTypes.CACHE_HIT,
        result: cacheHit,
        resetState: stringifiedCacheKey !== JSON.stringify(state.cacheKey)
      });
      return Promise.resolve(cacheHit);
    }
    dispatch({ type: actionTypes.LOADING, initialState });
    return client.request(revisedOperation, revisedOpts).then((result) => {
      if (revisedOpts.updateData && typeof revisedOpts.updateData !== "function") {
        throw new Error("options.updateData must be a function");
      }
      const actionResult = __spreadValues$2({}, result);
      if (revisedOpts.useCache) {
        actionResult.useCache = true;
        actionResult.cacheKey = revisedCacheKey;
        if (client.ssrMode) {
          const cacheValue = {
            error: actionResult.error,
            data: revisedOpts.updateData ? revisedOpts.updateData(state.data, actionResult.data) : actionResult.data
          };
          client.saveCache(revisedCacheKey, cacheValue);
        }
      }
      if (isMounted.current && revisedCacheKey === activeCacheKey.current) {
        dispatch({
          type: actionTypes.REQUEST_RESULT,
          updateData: revisedOpts.updateData,
          result: actionResult
        });
      }
      if (initialOpts.isMutation) {
        client.mutationsEmitter.emit(query, __spreadProps$1(__spreadValues$2({}, revisedOperation), {
          mutation: query,
          result: actionResult
        }));
      }
      return result;
    });
  }, [client, initialOpts, operation]);
  React.useEffect(() => {
    if (state.useCache && !client.ssrMode) {
      client.saveCache(state.cacheKey, state);
    }
  }, [client, state]);
  const reset = (desiredState = {}) => dispatch({
    type: actionTypes.RESET_STATE,
    initialState: __spreadValues$2(__spreadValues$2({}, initialState), desiredState)
  });
  return [fetchData, state, reset];
}

function createRefetchMutationsMap(refetchAfterMutations) {
  var mutations = Array.isArray(refetchAfterMutations) ? refetchAfterMutations : [refetchAfterMutations];
  var result = {};
  mutations.forEach(function (mutationInfo) {
    if (mutationInfo == null) return;
    var paramType = typeof mutationInfo;

    if (paramType === "string") {
      result[mutationInfo] = {};
    } else if (paramType === "object") {
      var filter = mutationInfo.filter,
          mutation = mutationInfo.mutation;
      result[mutation] = {
        filter: filter
      };
    }
  });
  return result;
}

var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const defaultOpts = {
  useCache: true,
  skip: false,
  throwErrors: false
};
function useQuery(query, opts = {}) {
  const allOpts = __spreadValues$1(__spreadValues$1({}, defaultOpts), opts);
  const contextClient = React.useContext(ClientContext);
  const client = opts.client || contextClient;
  const [calledDuringSSR, setCalledDuringSSR] = React.useState(false);
  const [queryReq, state] = useClientRequest(query, allOpts);
  if (!client) {
    throw new Error("useQuery() requires a client to be passed in the options or as a context value");
  }
  if (client.ssrMode && opts.ssr !== false && !calledDuringSSR && !opts.skipCache && !opts.skip) {
    if (!state.data && !state.error) {
      const p = queryReq();
      client.ssrPromises.push(p);
    }
    setCalledDuringSSR(true);
  }
  const stringifiedAllOpts = JSON.stringify(allOpts);
  React.useEffect(() => {
    if (allOpts.skip) {
      return;
    }
    queryReq();
  }, [query, stringifiedAllOpts]);
  React.useEffect(() => {
    if (state.error && allOpts.throwErrors) {
      throw state.error;
    }
  }, [state.error, allOpts.throwErrors]);
  const refetch = React.useCallback((options = {}) => queryReq(__spreadValues$1({
    skipCache: true,
    updateData: (_, data) => data
  }, options)), [queryReq]);
  React.useEffect(function subscribeToMutationsAndRefetch() {
    const mutationsMap = createRefetchMutationsMap(opts.refetchAfterMutations);
    const mutations = Object.keys(mutationsMap);
    const conditionalRefetch = ({ mutation, variables }) => {
      const { filter } = mutationsMap[mutation];
      if (!filter || variables && filter(variables)) {
        refetch();
      }
    };
    mutations.forEach((mutation) => {
      client.mutationsEmitter.on(mutation, conditionalRefetch);
    });
    return () => {
      mutations.forEach((mutation) => {
        client.mutationsEmitter.removeListener(mutation, conditionalRefetch);
      });
    };
  }, [opts.refetchAfterMutations, refetch, client.mutationsEmitter]);
  return __spreadProps(__spreadValues$1({}, state), {
    refetch
  });
}

function useSubscription(options, callback) {
  const callbackRef = useRef(callback);
  callbackRef.current = callback;
  const contextClient = useContext(ClientContext);
  const client = options.client || contextClient;
  if (!client) {
    throw new Error("useSubscription() requires a client to be passed in the options or as a context value");
  }
  const request = {
    query: options.query,
    variables: options.variables
  };
  useEffect(() => {
    const observable = client.createSubscription(request);
    const subscription = observable.subscribe({
      next: (result) => {
        callbackRef.current(result);
      },
      error: (errors) => {
        callbackRef.current({ errors });
      },
      complete: () => {
        subscription.unsubscribe();
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }, []);
}

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const useManualQuery = (query, options = {}) => useClientRequest(query, __spreadValues({ useCache: true, isManual: true }, options));
const useMutation = (query, options = {}) => useClientRequest(query, __spreadValues({ isMutation: true }, options));

export { ClientContext, GraphQLClient, LocalGraphQLClient, LocalGraphQLError, useClientRequest, useManualQuery, useMutation, useQuery, useSubscription };
